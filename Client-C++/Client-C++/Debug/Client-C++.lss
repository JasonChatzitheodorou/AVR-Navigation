
Client-C++.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000fd8  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000002ae  00800060  00000fd8  0000104c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .comment      00000030  00000000  00000000  000012fa  2**0
                  CONTENTS, READONLY
  3 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000132c  2**2
                  CONTENTS, READONLY
  4 .debug_aranges 00000198  00000000  00000000  00001368  2**3
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000261d  00000000  00000000  00001500  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000009cb  00000000  00000000  00003b1d  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00001046  00000000  00000000  000044e8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  0000063c  00000000  00000000  00005530  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000091f  00000000  00000000  00005b6c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00002246  00000000  00000000  0000648b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000148  00000000  00000000  000086d1  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
   8:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
   c:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  10:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  14:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  18:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  1c:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  20:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  24:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  28:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  2c:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  30:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  34:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  38:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  3c:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  40:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  44:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  48:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  4c:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>
  50:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d4 e0       	ldi	r29, 0x04	; 4
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	13 e0       	ldi	r17, 0x03	; 3
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e8 ed       	ldi	r30, 0xD8	; 216
  68:	ff e0       	ldi	r31, 0x0F	; 15
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	ae 30       	cpi	r26, 0x0E	; 14
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>
  76:	0e 94 e9 02 	call	0x5d2	; 0x5d2 <main>
  7a:	0c 94 ea 07 	jmp	0xfd4	; 0xfd4 <_exit>

0000007e <__bad_interrupt>:
  7e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000082 <lcd_init_sim>:
.global wait_msec

.section .text      

lcd_init_sim:
	push r24
  82:	8f 93       	push	r24
	push r25
  84:	9f 93       	push	r25
	
	ldi r24, 40
  86:	88 e2       	ldi	r24, 0x28	; 40
	ldi r25, 0
  88:	90 e0       	ldi	r25, 0x00	; 0
	rcall wait_msec
  8a:	71 d0       	rcall	.+226    	; 0x16e <wait_msec>
	
	ldi r24, 0x30
  8c:	80 e3       	ldi	r24, 0x30	; 48
	out PORTD, r24
  8e:	82 bb       	out	0x12, r24	; 18
	sbi PORTD, PD3
  90:	93 9a       	sbi	0x12, 3	; 18
	cbi PORTD, PD3
  92:	93 98       	cbi	0x12, 3	; 18
	ldi r24, 39
  94:	87 e2       	ldi	r24, 0x27	; 39
	ldi r25, 0
  96:	90 e0       	ldi	r25, 0x00	; 0
	rcall wait_usec
  98:	63 d0       	rcall	.+198    	; 0x160 <wait_usec>
	
	push r24
  9a:	8f 93       	push	r24
	push r25
  9c:	9f 93       	push	r25
	ldi r24,lo8(1000)
  9e:	88 ee       	ldi	r24, 0xE8	; 232
	ldi r25,hi8(1000)
  a0:	93 e0       	ldi	r25, 0x03	; 3
	rcall wait_usec
  a2:	5e d0       	rcall	.+188    	; 0x160 <wait_usec>
	pop r25
  a4:	9f 91       	pop	r25
	pop r24
  a6:	8f 91       	pop	r24
	
	ldi r24, 0x30
  a8:	80 e3       	ldi	r24, 0x30	; 48
	out PORTD, r24
  aa:	82 bb       	out	0x12, r24	; 18
	sbi PORTD, PD3
  ac:	93 9a       	sbi	0x12, 3	; 18
	cbi PORTD, PD3
  ae:	93 98       	cbi	0x12, 3	; 18
	ldi r24,39
  b0:	87 e2       	ldi	r24, 0x27	; 39
	ldi r25,0
  b2:	90 e0       	ldi	r25, 0x00	; 0
	rcall wait_usec
  b4:	55 d0       	rcall	.+170    	; 0x160 <wait_usec>
	 
	push r24
  b6:	8f 93       	push	r24
	push r25
  b8:	9f 93       	push	r25
	ldi r24 ,lo8(1000)
  ba:	88 ee       	ldi	r24, 0xE8	; 232
	ldi r25 ,hi8(1000)
  bc:	93 e0       	ldi	r25, 0x03	; 3
	rcall wait_usec
  be:	50 d0       	rcall	.+160    	; 0x160 <wait_usec>
	pop r25
  c0:	9f 91       	pop	r25
	pop r24
  c2:	8f 91       	pop	r24
	
	ldi r24,0x20
  c4:	80 e2       	ldi	r24, 0x20	; 32
	out PORTD, r24
  c6:	82 bb       	out	0x12, r24	; 18
	sbi PORTD, PD3
  c8:	93 9a       	sbi	0x12, 3	; 18
	cbi PORTD, PD3
  ca:	93 98       	cbi	0x12, 3	; 18
	ldi r24,39
  cc:	87 e2       	ldi	r24, 0x27	; 39
	ldi r25,0
  ce:	90 e0       	ldi	r25, 0x00	; 0
	rcall wait_usec
  d0:	47 d0       	rcall	.+142    	; 0x160 <wait_usec>
	
	push r24
  d2:	8f 93       	push	r24
	push r25
  d4:	9f 93       	push	r25
	ldi r24 ,lo8(1000)
  d6:	88 ee       	ldi	r24, 0xE8	; 232
	ldi r25 ,hi8(1000)
  d8:	93 e0       	ldi	r25, 0x03	; 3
	rcall wait_usec
  da:	42 d0       	rcall	.+132    	; 0x160 <wait_usec>
	pop r25
  dc:	9f 91       	pop	r25
	pop r24
  de:	8f 91       	pop	r24
	
	ldi r24,0x28
  e0:	88 e2       	ldi	r24, 0x28	; 40
	rcall lcd_command_sim
  e2:	0c d0       	rcall	.+24     	; 0xfc <lcd_command_sim>
	
	ldi r24,0x0c
  e4:	8c e0       	ldi	r24, 0x0C	; 12
	rcall lcd_command_sim
  e6:	0a d0       	rcall	.+20     	; 0xfc <lcd_command_sim>
	
	ldi r24,0x01
  e8:	81 e0       	ldi	r24, 0x01	; 1
	rcall lcd_command_sim
  ea:	08 d0       	rcall	.+16     	; 0xfc <lcd_command_sim>
	
	ldi r24, lo8(1530)
  ec:	8a ef       	ldi	r24, 0xFA	; 250
	ldi r25, hi8(1530)
  ee:	95 e0       	ldi	r25, 0x05	; 5
	rcall wait_usec
  f0:	37 d0       	rcall	.+110    	; 0x160 <wait_usec>
	
	ldi r24 ,0x06
  f2:	86 e0       	ldi	r24, 0x06	; 6
	rcall lcd_command_sim
  f4:	03 d0       	rcall	.+6      	; 0xfc <lcd_command_sim>
	
	pop r25
  f6:	9f 91       	pop	r25
	pop r24
  f8:	8f 91       	pop	r24
	ret
  fa:	08 95       	ret

000000fc <lcd_command_sim>:

lcd_command_sim:
	push r24
  fc:	8f 93       	push	r24
	push r25
  fe:	9f 93       	push	r25
	cbi PORTD, PD2
 100:	92 98       	cbi	0x12, 2	; 18
	rcall write_2_nibbles_sim
 102:	10 d0       	rcall	.+32     	; 0x124 <write_2_nibbles_sim>
	ldi r24, 39
 104:	87 e2       	ldi	r24, 0x27	; 39
	ldi r25, 0
 106:	90 e0       	ldi	r25, 0x00	; 0
	rcall wait_usec
 108:	2b d0       	rcall	.+86     	; 0x160 <wait_usec>
	pop r25
 10a:	9f 91       	pop	r25
	pop r24
 10c:	8f 91       	pop	r24
	ret
 10e:	08 95       	ret

00000110 <lcd_data_sim>:

lcd_data_sim:
	push r24
 110:	8f 93       	push	r24
	push r25
 112:	9f 93       	push	r25
	sbi PORTD, PD2
 114:	92 9a       	sbi	0x12, 2	; 18
	rcall write_2_nibbles_sim
 116:	06 d0       	rcall	.+12     	; 0x124 <write_2_nibbles_sim>
	ldi r24 ,43
 118:	8b e2       	ldi	r24, 0x2B	; 43
	ldi r25 ,0
 11a:	90 e0       	ldi	r25, 0x00	; 0
	rcall wait_usec
 11c:	21 d0       	rcall	.+66     	; 0x160 <wait_usec>
	pop r25
 11e:	9f 91       	pop	r25
	pop r24
 120:	8f 91       	pop	r24
	ret
 122:	08 95       	ret

00000124 <write_2_nibbles_sim>:

write_2_nibbles_sim:
	push r24 
 124:	8f 93       	push	r24
	push r25
 126:	9f 93       	push	r25
	ldi r24 ,lo8(6000)
 128:	80 e7       	ldi	r24, 0x70	; 112
	ldi r25 ,hi8(6000)
 12a:	97 e1       	ldi	r25, 0x17	; 23
	rcall wait_usec
 12c:	19 d0       	rcall	.+50     	; 0x160 <wait_usec>
	pop r25
 12e:	9f 91       	pop	r25
	pop r24
 130:	8f 91       	pop	r24
	
	push r24
 132:	8f 93       	push	r24
	in r25, PIND
 134:	90 b3       	in	r25, 0x10	; 16
	andi r25, 0x0f
 136:	9f 70       	andi	r25, 0x0F	; 15
	andi r24, 0xf0
 138:	80 7f       	andi	r24, 0xF0	; 240
	add r24, r25
 13a:	89 0f       	add	r24, r25
	out PORTD, r24
 13c:	82 bb       	out	0x12, r24	; 18
	sbi PORTD, PD3
 13e:	93 9a       	sbi	0x12, 3	; 18
	cbi PORTD, PD3
 140:	93 98       	cbi	0x12, 3	; 18
	
	push r24
 142:	8f 93       	push	r24
	push r25
 144:	9f 93       	push	r25
	ldi r24 ,lo8(6000)
 146:	80 e7       	ldi	r24, 0x70	; 112
	ldi r25 ,hi8(6000)
 148:	97 e1       	ldi	r25, 0x17	; 23
	rcall wait_usec
 14a:	0a d0       	rcall	.+20     	; 0x160 <wait_usec>
	pop r25
 14c:	9f 91       	pop	r25
	pop r24
 14e:	8f 91       	pop	r24
	
	pop r24
 150:	8f 91       	pop	r24
	swap r24
 152:	82 95       	swap	r24
	andi r24 ,0xf0
 154:	80 7f       	andi	r24, 0xF0	; 240
	add r24, r25
 156:	89 0f       	add	r24, r25
	out PORTD, r24
 158:	82 bb       	out	0x12, r24	; 18
	sbi PORTD, PD3
 15a:	93 9a       	sbi	0x12, 3	; 18
	cbi PORTD, PD3
 15c:	93 98       	cbi	0x12, 3	; 18
	ret
 15e:	08 95       	ret

00000160 <wait_usec>:


wait_usec:
	sbiw r24, 1
 160:	01 97       	sbiw	r24, 0x01	; 1
	...
	nop 
	nop
	nop
	nop
	brne wait_usec
 16a:	d1 f7       	brne	.-12     	; 0x160 <wait_usec>
	ret 
 16c:	08 95       	ret

0000016e <wait_msec>:

wait_msec:
	push r24
 16e:	8f 93       	push	r24
	push r25
 170:	9f 93       	push	r25
	ldi r24, lo8(998)
 172:	86 ee       	ldi	r24, 0xE6	; 230
	ldi r25, hi8(998)
 174:	93 e0       	ldi	r25, 0x03	; 3
	rcall wait_usec
 176:	f4 df       	rcall	.-24     	; 0x160 <wait_usec>
	pop r25
 178:	9f 91       	pop	r25
	pop r24
 17a:	8f 91       	pop	r24
	sbiw r24, 1
 17c:	01 97       	sbiw	r24, 0x01	; 1
	brne wait_msec
 17e:	b9 f7       	brne	.-18     	; 0x16e <wait_msec>
 180:	08 95       	ret

00000182 <_Z16lcd_print_stringPKc>:
extern "C" void wait_msec(double ms);

#define lcd_clear() lcd_command_sim(0x01)

// Prints a string to LCD without \n in the end
void lcd_print_string(char const *s) {
 182:	0f 93       	push	r16
 184:	1f 93       	push	r17
 186:	cf 93       	push	r28
 188:	df 93       	push	r29
 18a:	8c 01       	movw	r16, r24
	int i = 0;
	lcd_clear();
 18c:	81 e0       	ldi	r24, 0x01	; 1
 18e:	0e 94 7e 00 	call	0xfc	; 0xfc <lcd_command_sim>
 192:	e8 01       	movw	r28, r16
	
	while (s[i] != '\n' && s[i] != '\0') {
 194:	89 91       	ld	r24, Y+
 196:	8a 30       	cpi	r24, 0x0A	; 10
 198:	29 f0       	breq	.+10     	; 0x1a4 <_Z16lcd_print_stringPKc+0x22>
 19a:	88 23       	and	r24, r24
 19c:	19 f0       	breq	.+6      	; 0x1a4 <_Z16lcd_print_stringPKc+0x22>
		lcd_data_sim(s[i++]);
 19e:	0e 94 88 00 	call	0x110	; 0x110 <lcd_data_sim>
// Prints a string to LCD without \n in the end
void lcd_print_string(char const *s) {
	int i = 0;
	lcd_clear();
	
	while (s[i] != '\n' && s[i] != '\0') {
 1a2:	f8 cf       	rjmp	.-16     	; 0x194 <_Z16lcd_print_stringPKc+0x12>
		lcd_data_sim(s[i++]);
	}
	
	return;
}
 1a4:	df 91       	pop	r29
 1a6:	cf 91       	pop	r28
 1a8:	1f 91       	pop	r17
 1aa:	0f 91       	pop	r16
 1ac:	08 95       	ret

000001ae <_Z13lcd_print_inti>:

// Prints an integer of at most 7 digits (+-1)
void lcd_print_int(int n){
 1ae:	cf 93       	push	r28
 1b0:	df 93       	push	r29
 1b2:	cd b7       	in	r28, 0x3d	; 61
 1b4:	de b7       	in	r29, 0x3e	; 62
 1b6:	2a 97       	sbiw	r28, 0x0a	; 10
 1b8:	0f b6       	in	r0, 0x3f	; 63
 1ba:	f8 94       	cli
 1bc:	de bf       	out	0x3e, r29	; 62
 1be:	0f be       	out	0x3f, r0	; 63
 1c0:	cd bf       	out	0x3d, r28	; 61
	char s[10] = "";
 1c2:	1a 82       	std	Y+2, r1	; 0x02
 1c4:	19 82       	std	Y+1, r1	; 0x01
 1c6:	fe 01       	movw	r30, r28
 1c8:	33 96       	adiw	r30, 0x03	; 3
 1ca:	28 e0       	ldi	r18, 0x08	; 8
 1cc:	df 01       	movw	r26, r30
 1ce:	1d 92       	st	X+, r1
 1d0:	2a 95       	dec	r18
 1d2:	e9 f7       	brne	.-6      	; 0x1ce <_Z13lcd_print_inti+0x20>
	itoa(n, s, 10);
 1d4:	4a e0       	ldi	r20, 0x0A	; 10
 1d6:	50 e0       	ldi	r21, 0x00	; 0
 1d8:	be 01       	movw	r22, r28
 1da:	6f 5f       	subi	r22, 0xFF	; 255
 1dc:	7f 4f       	sbci	r23, 0xFF	; 255
 1de:	0e 94 cf 03 	call	0x79e	; 0x79e <_Z4itoaiPci>
	lcd_print_string(s);
 1e2:	ce 01       	movw	r24, r28
 1e4:	01 96       	adiw	r24, 0x01	; 1
 1e6:	0e 94 c1 00 	call	0x182	; 0x182 <_Z16lcd_print_stringPKc>
}
 1ea:	2a 96       	adiw	r28, 0x0a	; 10
 1ec:	0f b6       	in	r0, 0x3f	; 63
 1ee:	f8 94       	cli
 1f0:	de bf       	out	0x3e, r29	; 62
 1f2:	0f be       	out	0x3f, r0	; 63
 1f4:	cd bf       	out	0x3d, r28	; 61
 1f6:	df 91       	pop	r29
 1f8:	cf 91       	pop	r28
 1fa:	08 95       	ret

000001fc <_Z8lcd_initv>:

// Captures PORTD and initializes LCD
void lcd_init(void) {
	DDRD = 0xFF;
 1fc:	8f ef       	ldi	r24, 0xFF	; 255
 1fe:	81 bb       	out	0x11, r24	; 17
	lcd_init_sim();
 200:	0c 94 41 00 	jmp	0x82	; 0x82 <lcd_init_sim>

00000204 <_Z15setupConnectioni>:

#include "string_functions.h"
#include "uart_functions.h"
#include "lcd_functions.h"

int setupConnection(int debug = 0) {
 204:	cf 93       	push	r28
 206:	df 93       	push	r29
 208:	ec 01       	movw	r28, r24
	if(connectToServer("jasonAP", "awesomePassword12345", debug)) {
 20a:	ac 01       	movw	r20, r24
 20c:	60 e6       	ldi	r22, 0x60	; 96
 20e:	70 e0       	ldi	r23, 0x00	; 0
 210:	85 e7       	ldi	r24, 0x75	; 117
 212:	90 e0       	ldi	r25, 0x00	; 0
 214:	0e 94 55 06 	call	0xcaa	; 0xcaa <_Z15connectToServerPKcS0_i>
 218:	89 2b       	or	r24, r25
 21a:	19 f0       	breq	.+6      	; 0x222 <_Z15setupConnectioni+0x1e>
		lcd_print_string("Couldn't connect");
 21c:	8d e7       	ldi	r24, 0x7D	; 125
 21e:	90 e0       	ldi	r25, 0x00	; 0
 220:	3b c0       	rjmp	.+118    	; 0x298 <_Z15setupConnectioni+0x94>
		return 1;
	}
	
	if(newSensor("direction", debug)) {
 222:	be 01       	movw	r22, r28
 224:	8e e9       	ldi	r24, 0x9E	; 158
 226:	90 e0       	ldi	r25, 0x00	; 0
 228:	0e 94 76 06 	call	0xcec	; 0xcec <_Z9newSensorPKci>
 22c:	89 2b       	or	r24, r25
 22e:	19 f0       	breq	.+6      	; 0x236 <_Z15setupConnectioni+0x32>
		lcd_print_string("Couldn't create direction");
 230:	8e e8       	ldi	r24, 0x8E	; 142
 232:	90 e0       	ldi	r25, 0x00	; 0
 234:	31 c0       	rjmp	.+98     	; 0x298 <_Z15setupConnectioni+0x94>
		return 1;
	}
	
	if(newSensor("clientAck", debug)) {
 236:	be 01       	movw	r22, r28
 238:	88 eb       	ldi	r24, 0xB8	; 184
 23a:	90 e0       	ldi	r25, 0x00	; 0
 23c:	0e 94 76 06 	call	0xcec	; 0xcec <_Z9newSensorPKci>
 240:	89 2b       	or	r24, r25
 242:	19 f0       	breq	.+6      	; 0x24a <_Z15setupConnectioni+0x46>
		lcd_print_string("Couldn't create clientAck");
 244:	88 ea       	ldi	r24, 0xA8	; 168
 246:	90 e0       	ldi	r25, 0x00	; 0
 248:	27 c0       	rjmp	.+78     	; 0x298 <_Z15setupConnectioni+0x94>
		return 1;
	}
	
	if(newSensor("x_end", debug)) {
 24a:	be 01       	movw	r22, r28
 24c:	82 ed       	ldi	r24, 0xD2	; 210
 24e:	90 e0       	ldi	r25, 0x00	; 0
 250:	0e 94 76 06 	call	0xcec	; 0xcec <_Z9newSensorPKci>
 254:	89 2b       	or	r24, r25
 256:	19 f0       	breq	.+6      	; 0x25e <_Z15setupConnectioni+0x5a>
		lcd_print_string("Couldn't create x_end");
 258:	82 ec       	ldi	r24, 0xC2	; 194
 25a:	90 e0       	ldi	r25, 0x00	; 0
 25c:	1d c0       	rjmp	.+58     	; 0x298 <_Z15setupConnectioni+0x94>
		return 1;
	}
	
	if(newSensor("y_end", debug)) {
 25e:	be 01       	movw	r22, r28
 260:	88 ee       	ldi	r24, 0xE8	; 232
 262:	90 e0       	ldi	r25, 0x00	; 0
 264:	0e 94 76 06 	call	0xcec	; 0xcec <_Z9newSensorPKci>
 268:	89 2b       	or	r24, r25
 26a:	19 f0       	breq	.+6      	; 0x272 <_Z15setupConnectioni+0x6e>
		lcd_print_string("Couldn't create y_end");
 26c:	88 ed       	ldi	r24, 0xD8	; 216
 26e:	90 e0       	ldi	r25, 0x00	; 0
 270:	13 c0       	rjmp	.+38     	; 0x298 <_Z15setupConnectioni+0x94>
		return 1;
	}
	
	if(newSensor("x_start", debug)) {
 272:	be 01       	movw	r22, r28
 274:	8e ef       	ldi	r24, 0xFE	; 254
 276:	90 e0       	ldi	r25, 0x00	; 0
 278:	0e 94 76 06 	call	0xcec	; 0xcec <_Z9newSensorPKci>
 27c:	89 2b       	or	r24, r25
 27e:	19 f0       	breq	.+6      	; 0x286 <_Z15setupConnectioni+0x82>
		lcd_print_string("Couldn't create x_start");
 280:	8e ee       	ldi	r24, 0xEE	; 238
 282:	90 e0       	ldi	r25, 0x00	; 0
 284:	09 c0       	rjmp	.+18     	; 0x298 <_Z15setupConnectioni+0x94>
		return 1;
	}
	
	if(newSensor("y_start", debug)) {
 286:	be 01       	movw	r22, r28
 288:	86 e1       	ldi	r24, 0x16	; 22
 28a:	91 e0       	ldi	r25, 0x01	; 1
 28c:	0e 94 76 06 	call	0xcec	; 0xcec <_Z9newSensorPKci>
 290:	00 97       	sbiw	r24, 0x00	; 0
 292:	31 f0       	breq	.+12     	; 0x2a0 <_Z15setupConnectioni+0x9c>
		lcd_print_string("Couldn't create y_start");
 294:	86 e0       	ldi	r24, 0x06	; 6
 296:	91 e0       	ldi	r25, 0x01	; 1
 298:	0e 94 c1 00 	call	0x182	; 0x182 <_Z16lcd_print_stringPKc>
		return 1;
 29c:	81 e0       	ldi	r24, 0x01	; 1
 29e:	90 e0       	ldi	r25, 0x00	; 0
	}
	
	return 0;
}
 2a0:	df 91       	pop	r29
 2a2:	cf 91       	pop	r28
 2a4:	08 95       	ret

000002a6 <_Z17lcdPrintDirectionii>:
 * 0 - Down
 * 1 - Left
 * 2 - Up
 * 3 - Right
*/
void lcdPrintDirection(int prev, int curr){
 2a6:	cf 93       	push	r28
 2a8:	df 93       	push	r29
 2aa:	fc 01       	movw	r30, r24
 2ac:	9b 01       	movw	r18, r22
	if(prev == curr) lcd_print_string("Continue straight\n");
 2ae:	86 17       	cp	r24, r22
 2b0:	97 07       	cpc	r25, r23
 2b2:	19 f4       	brne	.+6      	; 0x2ba <_Z17lcdPrintDirectionii+0x14>
 2b4:	8e e1       	ldi	r24, 0x1E	; 30
 2b6:	91 e0       	ldi	r25, 0x01	; 1
 2b8:	19 c0       	rjmp	.+50     	; 0x2ec <_Z17lcdPrintDirectionii+0x46>
	else if((prev + 1) % 4 == curr) lcd_print_string("Turn right\n");
 2ba:	c4 e0       	ldi	r28, 0x04	; 4
 2bc:	d0 e0       	ldi	r29, 0x00	; 0
 2be:	01 96       	adiw	r24, 0x01	; 1
 2c0:	be 01       	movw	r22, r28
 2c2:	0e 94 d6 07 	call	0xfac	; 0xfac <__divmodhi4>
 2c6:	28 17       	cp	r18, r24
 2c8:	39 07       	cpc	r19, r25
 2ca:	19 f4       	brne	.+6      	; 0x2d2 <_Z17lcdPrintDirectionii+0x2c>
 2cc:	81 e3       	ldi	r24, 0x31	; 49
 2ce:	91 e0       	ldi	r25, 0x01	; 1
 2d0:	0d c0       	rjmp	.+26     	; 0x2ec <_Z17lcdPrintDirectionii+0x46>
	else if((curr + 1) % 4 == prev) lcd_print_string("Turn left\n");
 2d2:	c9 01       	movw	r24, r18
 2d4:	01 96       	adiw	r24, 0x01	; 1
 2d6:	be 01       	movw	r22, r28
 2d8:	0e 94 d6 07 	call	0xfac	; 0xfac <__divmodhi4>
 2dc:	e8 17       	cp	r30, r24
 2de:	f9 07       	cpc	r31, r25
 2e0:	19 f4       	brne	.+6      	; 0x2e8 <_Z17lcdPrintDirectionii+0x42>
 2e2:	8d e3       	ldi	r24, 0x3D	; 61
 2e4:	91 e0       	ldi	r25, 0x01	; 1
 2e6:	02 c0       	rjmp	.+4      	; 0x2ec <_Z17lcdPrintDirectionii+0x46>
	else lcd_print_string("Turn back\n");
 2e8:	88 e4       	ldi	r24, 0x48	; 72
 2ea:	91 e0       	ldi	r25, 0x01	; 1
}
 2ec:	df 91       	pop	r29
 2ee:	cf 91       	pop	r28
*/
void lcdPrintDirection(int prev, int curr){
	if(prev == curr) lcd_print_string("Continue straight\n");
	else if((prev + 1) % 4 == curr) lcd_print_string("Turn right\n");
	else if((curr + 1) % 4 == prev) lcd_print_string("Turn left\n");
	else lcd_print_string("Turn back\n");
 2f0:	0c 94 c1 00 	jmp	0x182	; 0x182 <_Z16lcd_print_stringPKc>

000002f4 <_Z21resetSensorsDirectioni>:
}

// Prepares ESP sensors to receive direction
void resetSensorsDirection(int debug = 0){
 2f4:	cf 93       	push	r28
 2f6:	df 93       	push	r29
 2f8:	ec 01       	movw	r28, r24
	if(requestSensorValue("direction", debug)) lcd_print_string("Couldn't set direction");
 2fa:	bc 01       	movw	r22, r24
 2fc:	8e e9       	ldi	r24, 0x9E	; 158
 2fe:	90 e0       	ldi	r25, 0x00	; 0
 300:	0e 94 16 07 	call	0xe2c	; 0xe2c <_Z18requestSensorValuePKci>
 304:	89 2b       	or	r24, r25
 306:	21 f0       	breq	.+8      	; 0x310 <_Z21resetSensorsDirectioni+0x1c>
 308:	83 e5       	ldi	r24, 0x53	; 83
 30a:	91 e0       	ldi	r25, 0x01	; 1
 30c:	0e 94 c1 00 	call	0x182	; 0x182 <_Z16lcd_print_stringPKc>

	if(requestSensorValue("clientAck", debug)) lcd_print_string("Couldn't set clientAck\n");
 310:	be 01       	movw	r22, r28
 312:	88 eb       	ldi	r24, 0xB8	; 184
 314:	90 e0       	ldi	r25, 0x00	; 0
 316:	0e 94 16 07 	call	0xe2c	; 0xe2c <_Z18requestSensorValuePKci>
 31a:	89 2b       	or	r24, r25
 31c:	31 f0       	breq	.+12     	; 0x32a <_Z21resetSensorsDirectioni+0x36>
 31e:	8a e6       	ldi	r24, 0x6A	; 106
 320:	91 e0       	ldi	r25, 0x01	; 1
}
 322:	df 91       	pop	r29
 324:	cf 91       	pop	r28

// Prepares ESP sensors to receive direction
void resetSensorsDirection(int debug = 0){
	if(requestSensorValue("direction", debug)) lcd_print_string("Couldn't set direction");

	if(requestSensorValue("clientAck", debug)) lcd_print_string("Couldn't set clientAck\n");
 326:	0c 94 c1 00 	jmp	0x182	; 0x182 <_Z16lcd_print_stringPKc>
}
 32a:	df 91       	pop	r29
 32c:	cf 91       	pop	r28
 32e:	08 95       	ret

00000330 <_Z23resetSensorsCoordinatesiiiii>:

// Prepares ESP sensors to send coordinates of start and destination
void resetSensorsCoordinates(int x_start, int y_start, int x_end, int y_end, int debug = 0){
 330:	cf 92       	push	r12
 332:	df 92       	push	r13
 334:	ef 92       	push	r14
 336:	ff 92       	push	r15
 338:	0f 93       	push	r16
 33a:	1f 93       	push	r17
 33c:	cf 93       	push	r28
 33e:	df 93       	push	r29
 340:	6b 01       	movw	r12, r22
 342:	7a 01       	movw	r14, r20
 344:	e9 01       	movw	r28, r18
	if(setSensorInt("x_start", x_start, debug)) lcd_print_string("Couldn't set x_start\n");
 346:	a8 01       	movw	r20, r16
 348:	bc 01       	movw	r22, r24
 34a:	8e ef       	ldi	r24, 0xFE	; 254
 34c:	90 e0       	ldi	r25, 0x00	; 0
 34e:	0e 94 e1 06 	call	0xdc2	; 0xdc2 <_Z12setSensorIntPKcii>
 352:	89 2b       	or	r24, r25
 354:	21 f0       	breq	.+8      	; 0x35e <_Z23resetSensorsCoordinatesiiiii+0x2e>
 356:	82 e8       	ldi	r24, 0x82	; 130
 358:	91 e0       	ldi	r25, 0x01	; 1
 35a:	0e 94 c1 00 	call	0x182	; 0x182 <_Z16lcd_print_stringPKc>
	if(setSensorInt("y_start", y_start, debug)) lcd_print_string("Couldn't set y_start\n");
 35e:	a8 01       	movw	r20, r16
 360:	b6 01       	movw	r22, r12
 362:	86 e1       	ldi	r24, 0x16	; 22
 364:	91 e0       	ldi	r25, 0x01	; 1
 366:	0e 94 e1 06 	call	0xdc2	; 0xdc2 <_Z12setSensorIntPKcii>
 36a:	89 2b       	or	r24, r25
 36c:	21 f0       	breq	.+8      	; 0x376 <_Z23resetSensorsCoordinatesiiiii+0x46>
 36e:	88 e9       	ldi	r24, 0x98	; 152
 370:	91 e0       	ldi	r25, 0x01	; 1
 372:	0e 94 c1 00 	call	0x182	; 0x182 <_Z16lcd_print_stringPKc>
	
	if(setSensorInt("x_end", x_end, debug)) lcd_print_string("Couldn't set x_end\n");
 376:	a8 01       	movw	r20, r16
 378:	b7 01       	movw	r22, r14
 37a:	82 ed       	ldi	r24, 0xD2	; 210
 37c:	90 e0       	ldi	r25, 0x00	; 0
 37e:	0e 94 e1 06 	call	0xdc2	; 0xdc2 <_Z12setSensorIntPKcii>
 382:	89 2b       	or	r24, r25
 384:	21 f0       	breq	.+8      	; 0x38e <_Z23resetSensorsCoordinatesiiiii+0x5e>
 386:	8e ea       	ldi	r24, 0xAE	; 174
 388:	91 e0       	ldi	r25, 0x01	; 1
 38a:	0e 94 c1 00 	call	0x182	; 0x182 <_Z16lcd_print_stringPKc>
	if(setSensorInt("y_end", y_end, debug)) lcd_print_string("Couldn't set y_end\n");
 38e:	a8 01       	movw	r20, r16
 390:	be 01       	movw	r22, r28
 392:	88 ee       	ldi	r24, 0xE8	; 232
 394:	90 e0       	ldi	r25, 0x00	; 0
 396:	0e 94 e1 06 	call	0xdc2	; 0xdc2 <_Z12setSensorIntPKcii>
 39a:	89 2b       	or	r24, r25
 39c:	21 f0       	breq	.+8      	; 0x3a6 <_Z23resetSensorsCoordinatesiiiii+0x76>
 39e:	82 ec       	ldi	r24, 0xC2	; 194
 3a0:	91 e0       	ldi	r25, 0x01	; 1
 3a2:	0e 94 c1 00 	call	0x182	; 0x182 <_Z16lcd_print_stringPKc>
	
	if(requestSensorValue("clientAck", debug)) lcd_print_string("Couldn't set clientAck\n");
 3a6:	b8 01       	movw	r22, r16
 3a8:	88 eb       	ldi	r24, 0xB8	; 184
 3aa:	90 e0       	ldi	r25, 0x00	; 0
 3ac:	0e 94 16 07 	call	0xe2c	; 0xe2c <_Z18requestSensorValuePKci>
 3b0:	89 2b       	or	r24, r25
 3b2:	61 f0       	breq	.+24     	; 0x3cc <_Z23resetSensorsCoordinatesiiiii+0x9c>
 3b4:	8a e6       	ldi	r24, 0x6A	; 106
 3b6:	91 e0       	ldi	r25, 0x01	; 1
}
 3b8:	df 91       	pop	r29
 3ba:	cf 91       	pop	r28
 3bc:	1f 91       	pop	r17
 3be:	0f 91       	pop	r16
 3c0:	ff 90       	pop	r15
 3c2:	ef 90       	pop	r14
 3c4:	df 90       	pop	r13
 3c6:	cf 90       	pop	r12
	if(setSensorInt("y_start", y_start, debug)) lcd_print_string("Couldn't set y_start\n");
	
	if(setSensorInt("x_end", x_end, debug)) lcd_print_string("Couldn't set x_end\n");
	if(setSensorInt("y_end", y_end, debug)) lcd_print_string("Couldn't set y_end\n");
	
	if(requestSensorValue("clientAck", debug)) lcd_print_string("Couldn't set clientAck\n");
 3c8:	0c 94 c1 00 	jmp	0x182	; 0x182 <_Z16lcd_print_stringPKc>
}
 3cc:	df 91       	pop	r29
 3ce:	cf 91       	pop	r28
 3d0:	1f 91       	pop	r17
 3d2:	0f 91       	pop	r16
 3d4:	ff 90       	pop	r15
 3d6:	ef 90       	pop	r14
 3d8:	df 90       	pop	r13
 3da:	cf 90       	pop	r12
 3dc:	08 95       	ret

000003de <_Z15sendCoordinatesiiiii>:

// Sends user's coordinates of start and destination
int sendCoordinates(int x_start, int y_start, int x_end, int y_end, int debug = 0){
 3de:	6f 92       	push	r6
 3e0:	7f 92       	push	r7
 3e2:	8f 92       	push	r8
 3e4:	9f 92       	push	r9
 3e6:	af 92       	push	r10
 3e8:	bf 92       	push	r11
 3ea:	cf 92       	push	r12
 3ec:	df 92       	push	r13
 3ee:	ef 92       	push	r14
 3f0:	ff 92       	push	r15
 3f2:	0f 93       	push	r16
 3f4:	1f 93       	push	r17
 3f6:	cf 93       	push	r28
 3f8:	df 93       	push	r29
 3fa:	cd b7       	in	r28, 0x3d	; 61
 3fc:	de b7       	in	r29, 0x3e	; 62
 3fe:	e2 97       	sbiw	r28, 0x32	; 50
 400:	0f b6       	in	r0, 0x3f	; 63
 402:	f8 94       	cli
 404:	de bf       	out	0x3e, r29	; 62
 406:	0f be       	out	0x3f, r0	; 63
 408:	cd bf       	out	0x3d, r28	; 61
 40a:	6c 01       	movw	r12, r24
 40c:	5b 01       	movw	r10, r22
 40e:	4a 01       	movw	r8, r20
 410:	39 01       	movw	r6, r18
 412:	78 01       	movw	r14, r16
	char ack[CMD] = "";
 414:	1a 82       	std	Y+2, r1	; 0x02
 416:	19 82       	std	Y+1, r1	; 0x01
 418:	fe 01       	movw	r30, r28
 41a:	33 96       	adiw	r30, 0x03	; 3
 41c:	80 e3       	ldi	r24, 0x30	; 48
 41e:	df 01       	movw	r26, r30
 420:	1d 92       	st	X+, r1
 422:	8a 95       	dec	r24
 424:	e9 f7       	brne	.-6      	; 0x420 <__LOCK_REGION_LENGTH__+0x20>
	while(1){
		resetSensorsCoordinates(x_start, y_start, x_end, y_end, debug);
 426:	87 01       	movw	r16, r14
 428:	93 01       	movw	r18, r6
 42a:	a4 01       	movw	r20, r8
 42c:	b5 01       	movw	r22, r10
 42e:	c6 01       	movw	r24, r12
 430:	0e 94 98 01 	call	0x330	; 0x330 <_Z23resetSensorsCoordinatesiiiii>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 434:	bf ef       	ldi	r27, 0xFF	; 255
 436:	21 ee       	ldi	r18, 0xE1	; 225
 438:	84 e0       	ldi	r24, 0x04	; 4
 43a:	b1 50       	subi	r27, 0x01	; 1
 43c:	20 40       	sbci	r18, 0x00	; 0
 43e:	80 40       	sbci	r24, 0x00	; 0
 440:	e1 f7       	brne	.-8      	; 0x43a <__LOCK_REGION_LENGTH__+0x3a>
 442:	00 c0       	rjmp	.+0      	; 0x444 <__LOCK_REGION_LENGTH__+0x44>
 444:	00 00       	nop
		
		// Delay so that the server will have enough time to send
		_delay_ms(200);
		
		if(clientTransmit(debug)) lcd_print_string("Couldn't transmit destination\n");
 446:	c7 01       	movw	r24, r14
 448:	0e 94 8c 07 	call	0xf18	; 0xf18 <_Z14clientTransmiti>
 44c:	89 2b       	or	r24, r25
 44e:	21 f0       	breq	.+8      	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
 450:	86 ed       	ldi	r24, 0xD6	; 214
 452:	91 e0       	ldi	r25, 0x01	; 1
 454:	0e 94 c1 00 	call	0x182	; 0x182 <_Z16lcd_print_stringPKc>
		
		getSensorString("clientAck", ack, debug);
 458:	a7 01       	movw	r20, r14
 45a:	be 01       	movw	r22, r28
 45c:	6f 5f       	subi	r22, 0xFF	; 255
 45e:	7f 4f       	sbci	r23, 0xFF	; 255
 460:	88 eb       	ldi	r24, 0xB8	; 184
 462:	90 e0       	ldi	r25, 0x00	; 0
 464:	0e 94 1b 07 	call	0xe36	; 0xe36 <_Z15getSensorStringPKcPci>
		lcd_print_string(ack);
 468:	ce 01       	movw	r24, r28
 46a:	01 96       	adiw	r24, 0x01	; 1
 46c:	0e 94 c1 00 	call	0x182	; 0x182 <_Z16lcd_print_stringPKc>
		
		// Check whether the message was received by the server
		if(!strcmp(ack, "request\n")){
 470:	65 ef       	ldi	r22, 0xF5	; 245
 472:	71 e0       	ldi	r23, 0x01	; 1
 474:	ce 01       	movw	r24, r28
 476:	01 96       	adiw	r24, 0x01	; 1
 478:	0e 94 57 03 	call	0x6ae	; 0x6ae <_Z6strcmpPKcS0_>
 47c:	89 2b       	or	r24, r25
 47e:	51 f4       	brne	.+20     	; 0x494 <__stack+0x35>
 480:	9f ef       	ldi	r25, 0xFF	; 255
 482:	a4 e3       	ldi	r26, 0x34	; 52
 484:	bc e0       	ldi	r27, 0x0C	; 12
 486:	91 50       	subi	r25, 0x01	; 1
 488:	a0 40       	sbci	r26, 0x00	; 0
 48a:	b0 40       	sbci	r27, 0x00	; 0
 48c:	e1 f7       	brne	.-8      	; 0x486 <__stack+0x27>
 48e:	00 c0       	rjmp	.+0      	; 0x490 <__stack+0x31>
 490:	00 00       	nop
 492:	c9 cf       	rjmp	.-110    	; 0x426 <__LOCK_REGION_LENGTH__+0x26>
		
		else break;
	}
	
	return 0;
}
 494:	80 e0       	ldi	r24, 0x00	; 0
 496:	90 e0       	ldi	r25, 0x00	; 0
 498:	e2 96       	adiw	r28, 0x32	; 50
 49a:	0f b6       	in	r0, 0x3f	; 63
 49c:	f8 94       	cli
 49e:	de bf       	out	0x3e, r29	; 62
 4a0:	0f be       	out	0x3f, r0	; 63
 4a2:	cd bf       	out	0x3d, r28	; 61
 4a4:	df 91       	pop	r29
 4a6:	cf 91       	pop	r28
 4a8:	1f 91       	pop	r17
 4aa:	0f 91       	pop	r16
 4ac:	ff 90       	pop	r15
 4ae:	ef 90       	pop	r14
 4b0:	df 90       	pop	r13
 4b2:	cf 90       	pop	r12
 4b4:	bf 90       	pop	r11
 4b6:	af 90       	pop	r10
 4b8:	9f 90       	pop	r9
 4ba:	8f 90       	pop	r8
 4bc:	7f 90       	pop	r7
 4be:	6f 90       	pop	r6
 4c0:	08 95       	ret

000004c2 <_Z14readDirectionsii>:

// Reads directions from the server
// Returns the direction {0, 1, 2, 3} or -1 if we reached the destination
int readDirections(int prev_direction, int debug = 0){
 4c2:	8f 92       	push	r8
 4c4:	9f 92       	push	r9
 4c6:	bf 92       	push	r11
 4c8:	cf 92       	push	r12
 4ca:	df 92       	push	r13
 4cc:	ef 92       	push	r14
 4ce:	ff 92       	push	r15
 4d0:	0f 93       	push	r16
 4d2:	1f 93       	push	r17
 4d4:	cf 93       	push	r28
 4d6:	df 93       	push	r29
 4d8:	cd b7       	in	r28, 0x3d	; 61
 4da:	de b7       	in	r29, 0x3e	; 62
 4dc:	e2 97       	sbiw	r28, 0x32	; 50
 4de:	0f b6       	in	r0, 0x3f	; 63
 4e0:	f8 94       	cli
 4e2:	de bf       	out	0x3e, r29	; 62
 4e4:	0f be       	out	0x3f, r0	; 63
 4e6:	cd bf       	out	0x3d, r28	; 61
 4e8:	6c 01       	movw	r12, r24
 4ea:	7b 01       	movw	r14, r22
		// Delay so that the server will have enough time to send
		_delay_ms(200);
		
		if(clientTransmit(debug)) lcd_print_string("Couldn't transmit\n");
		
		char ack[CMD] = "";
 4ec:	80 e3       	ldi	r24, 0x30	; 48
 4ee:	b8 2e       	mov	r11, r24
 4f0:	4e 01       	movw	r8, r28
 4f2:	23 e0       	ldi	r18, 0x03	; 3
 4f4:	82 0e       	add	r8, r18
 4f6:	91 1c       	adc	r9, r1

// Reads directions from the server
// Returns the direction {0, 1, 2, 3} or -1 if we reached the destination
int readDirections(int prev_direction, int debug = 0){
	while(1){
		resetSensorsDirection(debug);
 4f8:	c7 01       	movw	r24, r14
 4fa:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <_Z21resetSensorsDirectioni>
 4fe:	8f ef       	ldi	r24, 0xFF	; 255
 500:	91 ee       	ldi	r25, 0xE1	; 225
 502:	e4 e0       	ldi	r30, 0x04	; 4
 504:	81 50       	subi	r24, 0x01	; 1
 506:	90 40       	sbci	r25, 0x00	; 0
 508:	e0 40       	sbci	r30, 0x00	; 0
 50a:	e1 f7       	brne	.-8      	; 0x504 <_Z14readDirectionsii+0x42>
 50c:	00 c0       	rjmp	.+0      	; 0x50e <_Z14readDirectionsii+0x4c>
 50e:	00 00       	nop
		
		// Delay so that the server will have enough time to send
		_delay_ms(200);
		
		if(clientTransmit(debug)) lcd_print_string("Couldn't transmit\n");
 510:	c7 01       	movw	r24, r14
 512:	0e 94 8c 07 	call	0xf18	; 0xf18 <_Z14clientTransmiti>
 516:	89 2b       	or	r24, r25
 518:	21 f0       	breq	.+8      	; 0x522 <_Z14readDirectionsii+0x60>
 51a:	8e ef       	ldi	r24, 0xFE	; 254
 51c:	91 e0       	ldi	r25, 0x01	; 1
 51e:	0e 94 c1 00 	call	0x182	; 0x182 <_Z16lcd_print_stringPKc>
		
		char ack[CMD] = "";
 522:	1a 82       	std	Y+2, r1	; 0x02
 524:	19 82       	std	Y+1, r1	; 0x01
 526:	f4 01       	movw	r30, r8
 528:	2b 2d       	mov	r18, r11
 52a:	11 92       	st	Z+, r1
 52c:	2a 95       	dec	r18
 52e:	e9 f7       	brne	.-6      	; 0x52a <_Z14readDirectionsii+0x68>
		getSensorString("clientAck", ack, debug);
 530:	a7 01       	movw	r20, r14
 532:	be 01       	movw	r22, r28
 534:	6f 5f       	subi	r22, 0xFF	; 255
 536:	7f 4f       	sbci	r23, 0xFF	; 255
 538:	88 eb       	ldi	r24, 0xB8	; 184
 53a:	90 e0       	ldi	r25, 0x00	; 0
 53c:	0e 94 1b 07 	call	0xe36	; 0xe36 <_Z15getSensorStringPKcPci>
		lcd_print_string(ack);
 540:	ce 01       	movw	r24, r28
 542:	01 96       	adiw	r24, 0x01	; 1
 544:	0e 94 c1 00 	call	0x182	; 0x182 <_Z16lcd_print_stringPKc>
		
		int direction = getSensorValue("direction", debug);
 548:	b7 01       	movw	r22, r14
 54a:	8e e9       	ldi	r24, 0x9E	; 158
 54c:	90 e0       	ldi	r25, 0x00	; 0
 54e:	0e 94 56 07 	call	0xeac	; 0xeac <_Z14getSensorValuePKci>
 552:	8c 01       	movw	r16, r24
		lcd_print_int(direction);
 554:	0e 94 d7 00 	call	0x1ae	; 0x1ae <_Z13lcd_print_inti>
		
		// Check whether the direction was received
		if(direction == -1 || !strcmp(ack, "request\n")) {
 558:	0f 3f       	cpi	r16, 0xFF	; 255
 55a:	8f ef       	ldi	r24, 0xFF	; 255
 55c:	18 07       	cpc	r17, r24
 55e:	41 f0       	breq	.+16     	; 0x570 <_Z14readDirectionsii+0xae>
 560:	65 ef       	ldi	r22, 0xF5	; 245
 562:	71 e0       	ldi	r23, 0x01	; 1
 564:	ce 01       	movw	r24, r28
 566:	01 96       	adiw	r24, 0x01	; 1
 568:	0e 94 57 03 	call	0x6ae	; 0x6ae <_Z6strcmpPKcS0_>
 56c:	89 2b       	or	r24, r25
 56e:	51 f4       	brne	.+20     	; 0x584 <_Z14readDirectionsii+0xc2>
 570:	9f ef       	ldi	r25, 0xFF	; 255
 572:	e9 e6       	ldi	r30, 0x69	; 105
 574:	f8 e1       	ldi	r31, 0x18	; 24
 576:	91 50       	subi	r25, 0x01	; 1
 578:	e0 40       	sbci	r30, 0x00	; 0
 57a:	f0 40       	sbci	r31, 0x00	; 0
 57c:	e1 f7       	brne	.-8      	; 0x576 <_Z14readDirectionsii+0xb4>
 57e:	00 c0       	rjmp	.+0      	; 0x580 <_Z14readDirectionsii+0xbe>
 580:	00 00       	nop
 582:	ba cf       	rjmp	.-140    	; 0x4f8 <_Z14readDirectionsii+0x36>
			_delay_ms(1000);
			continue;
		}
		
		else if(direction == 4){
 584:	04 30       	cpi	r16, 0x04	; 4
 586:	11 05       	cpc	r17, r1
 588:	19 f4       	brne	.+6      	; 0x590 <_Z14readDirectionsii+0xce>
			lcd_print_string("Finished!\n");
 58a:	81 e1       	ldi	r24, 0x11	; 17
 58c:	92 e0       	ldi	r25, 0x02	; 2
 58e:	05 c0       	rjmp	.+10     	; 0x59a <_Z14readDirectionsii+0xd8>
			return -1;
		}
		
		else if(direction == 5){
 590:	05 30       	cpi	r16, 0x05	; 5
 592:	11 05       	cpc	r17, r1
 594:	39 f4       	brne	.+14     	; 0x5a4 <_Z14readDirectionsii+0xe2>
			lcd_print_string("Impossible destination\n");
 596:	8c e1       	ldi	r24, 0x1C	; 28
 598:	92 e0       	ldi	r25, 0x02	; 2
 59a:	0e 94 c1 00 	call	0x182	; 0x182 <_Z16lcd_print_stringPKc>
			return -1;
 59e:	8f ef       	ldi	r24, 0xFF	; 255
 5a0:	9f ef       	ldi	r25, 0xFF	; 255
 5a2:	05 c0       	rjmp	.+10     	; 0x5ae <_Z14readDirectionsii+0xec>
		}
		
		else{
			lcdPrintDirection(prev_direction, direction);
 5a4:	b8 01       	movw	r22, r16
 5a6:	c6 01       	movw	r24, r12
 5a8:	0e 94 53 01 	call	0x2a6	; 0x2a6 <_Z17lcdPrintDirectionii>
			
			return direction;
 5ac:	c8 01       	movw	r24, r16
		}
	}
}
 5ae:	e2 96       	adiw	r28, 0x32	; 50
 5b0:	0f b6       	in	r0, 0x3f	; 63
 5b2:	f8 94       	cli
 5b4:	de bf       	out	0x3e, r29	; 62
 5b6:	0f be       	out	0x3f, r0	; 63
 5b8:	cd bf       	out	0x3d, r28	; 61
 5ba:	df 91       	pop	r29
 5bc:	cf 91       	pop	r28
 5be:	1f 91       	pop	r17
 5c0:	0f 91       	pop	r16
 5c2:	ff 90       	pop	r15
 5c4:	ef 90       	pop	r14
 5c6:	df 90       	pop	r13
 5c8:	cf 90       	pop	r12
 5ca:	bf 90       	pop	r11
 5cc:	9f 90       	pop	r9
 5ce:	8f 90       	pop	r8
 5d0:	08 95       	ret

000005d2 <main>:

int main(void)
{
    DDRB = 0;
 5d2:	17 ba       	out	0x17, r1	; 23
    usart_init();
 5d4:	0e 94 72 04 	call	0x8e4	; 0x8e4 <_Z10usart_initv>
    lcd_init();
 5d8:	0e 94 fe 00 	call	0x1fc	; 0x1fc <_Z8lcd_initv>
	lcd_print_string("Starting ...\n");
 5dc:	84 e3       	ldi	r24, 0x34	; 52
 5de:	92 e0       	ldi	r25, 0x02	; 2
 5e0:	0e 94 c1 00 	call	0x182	; 0x182 <_Z16lcd_print_stringPKc>
	
	int curr_direction, prev_direction;
	int x_end, y_end;
	int x_start, y_start;
	
	restart(ESP_DEBUG);
 5e4:	80 e0       	ldi	r24, 0x00	; 0
 5e6:	90 e0       	ldi	r25, 0x00	; 0
 5e8:	0e 94 5e 05 	call	0xabc	; 0xabc <_Z7restarti>
		
		//lcd_print_string("Give y of destination with #\n");
		//y_end = readKeyboardInt(delimeter);
		
		// Connect to server
		lcd_print_string("Connecting to server ...\n");
 5ec:	82 e4       	ldi	r24, 0x42	; 66
 5ee:	92 e0       	ldi	r25, 0x02	; 2
 5f0:	0e 94 c1 00 	call	0x182	; 0x182 <_Z16lcd_print_stringPKc>
		while(setupConnection(ESP_DEBUG)) transmitString("Retry to connect\n");
 5f4:	80 e0       	ldi	r24, 0x00	; 0
 5f6:	90 e0       	ldi	r25, 0x00	; 0
 5f8:	0e 94 02 01 	call	0x204	; 0x204 <_Z15setupConnectioni>
 5fc:	89 2b       	or	r24, r25
 5fe:	29 f0       	breq	.+10     	; 0x60a <main+0x38>
 600:	8c e5       	ldi	r24, 0x5C	; 92
 602:	92 e0       	ldi	r25, 0x02	; 2
 604:	0e 94 83 04 	call	0x906	; 0x906 <_Z14transmitStringPKc>
 608:	f5 cf       	rjmp	.-22     	; 0x5f4 <main+0x22>
		
		// Send destination to server
		sendCoordinates(x_start, y_start, x_end, y_end, ESP_DEBUG);
 60a:	00 e0       	ldi	r16, 0x00	; 0
 60c:	10 e0       	ldi	r17, 0x00	; 0
 60e:	21 e0       	ldi	r18, 0x01	; 1
 610:	30 e0       	ldi	r19, 0x00	; 0
 612:	46 e0       	ldi	r20, 0x06	; 6
 614:	50 e0       	ldi	r21, 0x00	; 0
 616:	60 e0       	ldi	r22, 0x00	; 0
 618:	70 e0       	ldi	r23, 0x00	; 0
 61a:	80 e0       	ldi	r24, 0x00	; 0
 61c:	90 e0       	ldi	r25, 0x00	; 0
 61e:	0e 94 ef 01 	call	0x3de	; 0x3de <_Z15sendCoordinatesiiiii>
		
		// Prompt to start
	    lcd_print_string("Press B0 to continue ...\n");
 622:	8e e6       	ldi	r24, 0x6E	; 110
 624:	92 e0       	ldi	r25, 0x02	; 2
 626:	0e 94 c1 00 	call	0x182	; 0x182 <_Z16lcd_print_stringPKc>
	    while(!PINB) _delay_ms(2);
 62a:	86 b3       	in	r24, 0x16	; 22
 62c:	81 11       	cpse	r24, r1
 62e:	07 c0       	rjmp	.+14     	; 0x63e <main+0x6c>
 630:	8f e9       	ldi	r24, 0x9F	; 159
 632:	9f e0       	ldi	r25, 0x0F	; 15
 634:	01 97       	sbiw	r24, 0x01	; 1
 636:	f1 f7       	brne	.-4      	; 0x634 <main+0x62>
 638:	00 c0       	rjmp	.+0      	; 0x63a <main+0x68>
 63a:	00 00       	nop
 63c:	f6 cf       	rjmp	.-20     	; 0x62a <main+0x58>
		while(PINB) _delay_ms(2);
 63e:	86 b3       	in	r24, 0x16	; 22
 640:	88 23       	and	r24, r24
 642:	39 f0       	breq	.+14     	; 0x652 <main+0x80>
 644:	8f e9       	ldi	r24, 0x9F	; 159
 646:	9f e0       	ldi	r25, 0x0F	; 15
 648:	01 97       	sbiw	r24, 0x01	; 1
 64a:	f1 f7       	brne	.-4      	; 0x648 <main+0x76>
 64c:	00 c0       	rjmp	.+0      	; 0x64e <main+0x7c>
 64e:	00 00       	nop
 650:	f6 cf       	rjmp	.-20     	; 0x63e <main+0x6c>
 652:	c0 e0       	ldi	r28, 0x00	; 0
 654:	d0 e0       	ldi	r29, 0x00	; 0
		
		// Keep reading directions until we finish
		while(curr_direction != -1){
			prev_direction = curr_direction;
			
			lcd_print_string("Waiting for direction ...\n");
 656:	88 e8       	ldi	r24, 0x88	; 136
 658:	92 e0       	ldi	r25, 0x02	; 2
 65a:	0e 94 c1 00 	call	0x182	; 0x182 <_Z16lcd_print_stringPKc>
			curr_direction = readDirections(prev_direction, ESP_DEBUG);
 65e:	60 e0       	ldi	r22, 0x00	; 0
 660:	70 e0       	ldi	r23, 0x00	; 0
 662:	ce 01       	movw	r24, r28
 664:	0e 94 61 02 	call	0x4c2	; 0x4c2 <_Z14readDirectionsii>
 668:	ec 01       	movw	r28, r24
			
			while(!PINB) _delay_ms(2);
 66a:	86 b3       	in	r24, 0x16	; 22
 66c:	81 11       	cpse	r24, r1
 66e:	07 c0       	rjmp	.+14     	; 0x67e <main+0xac>
 670:	8f e9       	ldi	r24, 0x9F	; 159
 672:	9f e0       	ldi	r25, 0x0F	; 15
 674:	01 97       	sbiw	r24, 0x01	; 1
 676:	f1 f7       	brne	.-4      	; 0x674 <main+0xa2>
 678:	00 c0       	rjmp	.+0      	; 0x67a <main+0xa8>
 67a:	00 00       	nop
 67c:	f6 cf       	rjmp	.-20     	; 0x66a <main+0x98>
			while(PINB) _delay_ms(2);
 67e:	86 b3       	in	r24, 0x16	; 22
 680:	88 23       	and	r24, r24
 682:	39 f0       	breq	.+14     	; 0x692 <main+0xc0>
 684:	8f e9       	ldi	r24, 0x9F	; 159
 686:	9f e0       	ldi	r25, 0x0F	; 15
 688:	01 97       	sbiw	r24, 0x01	; 1
 68a:	f1 f7       	brne	.-4      	; 0x688 <main+0xb6>
 68c:	00 c0       	rjmp	.+0      	; 0x68e <main+0xbc>
 68e:	00 00       	nop
 690:	f6 cf       	rjmp	.-20     	; 0x67e <main+0xac>
 692:	9f ef       	ldi	r25, 0xFF	; 255
 694:	24 e3       	ldi	r18, 0x34	; 52
 696:	8c e0       	ldi	r24, 0x0C	; 12
 698:	91 50       	subi	r25, 0x01	; 1
 69a:	20 40       	sbci	r18, 0x00	; 0
 69c:	80 40       	sbci	r24, 0x00	; 0
 69e:	e1 f7       	brne	.-8      	; 0x698 <main+0xc6>
 6a0:	00 c0       	rjmp	.+0      	; 0x6a2 <main+0xd0>
 6a2:	00 00       	nop
	    lcd_print_string("Press B0 to continue ...\n");
	    while(!PINB) _delay_ms(2);
		while(PINB) _delay_ms(2);
		
		// Keep reading directions until we finish
		while(curr_direction != -1){
 6a4:	cf 3f       	cpi	r28, 0xFF	; 255
 6a6:	9f ef       	ldi	r25, 0xFF	; 255
 6a8:	d9 07       	cpc	r29, r25
 6aa:	a9 f6       	brne	.-86     	; 0x656 <main+0x84>
 6ac:	9f cf       	rjmp	.-194    	; 0x5ec <main+0x1a>

000006ae <_Z6strcmpPKcS0_>:
 *
 * Created: 3/7/2021 11:21:43
 *  Author: Jason
 */ 

int strcmp(const char *s1, const char *s2) {
 6ae:	dc 01       	movw	r26, r24
 6b0:	fb 01       	movw	r30, r22
	const unsigned char *p1 = (const unsigned char *)s1;
	const unsigned char *p2 = (const unsigned char *)s2;

	while (*p1 != '\0') {
 6b2:	2d 91       	ld	r18, X+
 6b4:	22 23       	and	r18, r18
 6b6:	41 f0       	breq	.+16     	; 0x6c8 <_Z6strcmpPKcS0_+0x1a>
		if (*p2 == '\0') return  1;
 6b8:	91 91       	ld	r25, Z+
 6ba:	99 23       	and	r25, r25
 6bc:	99 f0       	breq	.+38     	; 0x6e4 <_Z6strcmpPKcS0_+0x36>
		if (*p2 > *p1)   return -1;
 6be:	29 17       	cp	r18, r25
 6c0:	70 f0       	brcs	.+28     	; 0x6de <_Z6strcmpPKcS0_+0x30>
		if (*p1 > *p2)   return  1;
 6c2:	92 17       	cp	r25, r18
 6c4:	b0 f7       	brcc	.-20     	; 0x6b2 <_Z6strcmpPKcS0_+0x4>
 6c6:	0e c0       	rjmp	.+28     	; 0x6e4 <_Z6strcmpPKcS0_+0x36>

		p1++;
		p2++;
	}

	if (*p2 != '\0') return -1;
 6c8:	81 e0       	ldi	r24, 0x01	; 1
 6ca:	90 e0       	ldi	r25, 0x00	; 0
 6cc:	20 81       	ld	r18, Z
 6ce:	21 11       	cpse	r18, r1
 6d0:	02 c0       	rjmp	.+4      	; 0x6d6 <_Z6strcmpPKcS0_+0x28>
 6d2:	80 e0       	ldi	r24, 0x00	; 0
 6d4:	90 e0       	ldi	r25, 0x00	; 0
 6d6:	91 95       	neg	r25
 6d8:	81 95       	neg	r24
 6da:	91 09       	sbc	r25, r1
 6dc:	08 95       	ret
	const unsigned char *p1 = (const unsigned char *)s1;
	const unsigned char *p2 = (const unsigned char *)s2;

	while (*p1 != '\0') {
		if (*p2 == '\0') return  1;
		if (*p2 > *p1)   return -1;
 6de:	8f ef       	ldi	r24, 0xFF	; 255
 6e0:	9f ef       	ldi	r25, 0xFF	; 255
 6e2:	08 95       	ret
int strcmp(const char *s1, const char *s2) {
	const unsigned char *p1 = (const unsigned char *)s1;
	const unsigned char *p2 = (const unsigned char *)s2;

	while (*p1 != '\0') {
		if (*p2 == '\0') return  1;
 6e4:	81 e0       	ldi	r24, 0x01	; 1
 6e6:	90 e0       	ldi	r25, 0x00	; 0
	}

	if (*p2 != '\0') return -1;

	return 0;
}
 6e8:	08 95       	ret

000006ea <_Z6strcatPcPKc>:

// Make sure to allocate enough size on dest
char *strcat(char *dest, const char *src)
{
 6ea:	cf 93       	push	r28
 6ec:	df 93       	push	r29
 6ee:	dc 01       	movw	r26, r24
 6f0:	fd 01       	movw	r30, r26
 6f2:	e8 1b       	sub	r30, r24
 6f4:	f9 0b       	sbc	r31, r25
	int i,j;
	for (i = 0; dest[i] != '\0'; i++);
 6f6:	2d 91       	ld	r18, X+
 6f8:	21 11       	cpse	r18, r1
 6fa:	fa cf       	rjmp	.-12     	; 0x6f0 <_Z6strcatPcPKc+0x6>
 6fc:	e8 0f       	add	r30, r24
 6fe:	f9 1f       	adc	r31, r25
 700:	db 01       	movw	r26, r22
 702:	ef 01       	movw	r28, r30
 704:	9d 01       	movw	r18, r26
 706:	26 1b       	sub	r18, r22
 708:	37 0b       	sbc	r19, r23
	for (j = 0; src[j] != '\0'; j++) dest[i+j] = src[j];
 70a:	4d 91       	ld	r20, X+
 70c:	44 23       	and	r20, r20
 70e:	11 f0       	breq	.+4      	; 0x714 <_Z6strcatPcPKc+0x2a>
 710:	41 93       	st	Z+, r20
 712:	f8 cf       	rjmp	.-16     	; 0x704 <_Z6strcatPcPKc+0x1a>
	dest[i+j] = '\0';
 714:	fe 01       	movw	r30, r28
 716:	e2 0f       	add	r30, r18
 718:	f3 1f       	adc	r31, r19
 71a:	10 82       	st	Z, r1
	return dest;
}
 71c:	df 91       	pop	r29
 71e:	cf 91       	pop	r28
 720:	08 95       	ret

00000722 <_Z6strcpyPcPKc>:

// dest should be at least as long as src
char *strcpy(char *dest, char const *src){
 722:	cf 93       	push	r28
 724:	df 93       	push	r29
 726:	ec 01       	movw	r28, r24
 728:	db 01       	movw	r26, r22
 72a:	fd 01       	movw	r30, r26
 72c:	e6 1b       	sub	r30, r22
 72e:	f7 0b       	sbc	r31, r23
	int i = 0;
	
	for(i = 0; src[i] != '\0'; i++) dest[i] = src[i];
 730:	2d 91       	ld	r18, X+
 732:	22 23       	and	r18, r18
 734:	11 f0       	breq	.+4      	; 0x73a <_Z6strcpyPcPKc+0x18>
 736:	29 93       	st	Y+, r18
 738:	f8 cf       	rjmp	.-16     	; 0x72a <_Z6strcpyPcPKc+0x8>
	dest[i] = '\0';
 73a:	e8 0f       	add	r30, r24
 73c:	f9 1f       	adc	r31, r25
 73e:	10 82       	st	Z, r1
	
	return dest;
}
 740:	df 91       	pop	r29
 742:	cf 91       	pop	r28
 744:	08 95       	ret

00000746 <_Z4atoiPKc>:

// Int to string
int atoi(const char *c){
	int value = 0;
	int sign = 1;
	if( *c == '+' || *c == '-' )
 746:	fc 01       	movw	r30, r24
 748:	20 81       	ld	r18, Z
 74a:	2b 32       	cpi	r18, 0x2B	; 43
 74c:	29 f0       	breq	.+10     	; 0x758 <_Z4atoiPKc+0x12>
 74e:	2d 32       	cpi	r18, 0x2D	; 45
 750:	39 f4       	brne	.+14     	; 0x760 <_Z4atoiPKc+0x1a>
	{
		if( *c == '-' ) sign = -1;
 752:	4f ef       	ldi	r20, 0xFF	; 255
 754:	5f ef       	ldi	r21, 0xFF	; 255
 756:	02 c0       	rjmp	.+4      	; 0x75c <_Z4atoiPKc+0x16>
}

// Int to string
int atoi(const char *c){
	int value = 0;
	int sign = 1;
 758:	41 e0       	ldi	r20, 0x01	; 1
 75a:	50 e0       	ldi	r21, 0x00	; 0
	if( *c == '+' || *c == '-' )
	{
		if( *c == '-' ) sign = -1;
		c++;
 75c:	01 96       	adiw	r24, 0x01	; 1
 75e:	02 c0       	rjmp	.+4      	; 0x764 <_Z4atoiPKc+0x1e>
}

// Int to string
int atoi(const char *c){
	int value = 0;
	int sign = 1;
 760:	41 e0       	ldi	r20, 0x01	; 1
 762:	50 e0       	ldi	r21, 0x00	; 0
 764:	fc 01       	movw	r30, r24
 766:	20 e0       	ldi	r18, 0x00	; 0
 768:	30 e0       	ldi	r19, 0x00	; 0
		if( *c == '-' ) sign = -1;
		c++;
	}
	while (*c >= '0' && *c <= '9')
	{
		value *= 10;
 76a:	9a e0       	ldi	r25, 0x0A	; 10
	if( *c == '+' || *c == '-' )
	{
		if( *c == '-' ) sign = -1;
		c++;
	}
	while (*c >= '0' && *c <= '9')
 76c:	81 91       	ld	r24, Z+
 76e:	60 ed       	ldi	r22, 0xD0	; 208
 770:	68 0f       	add	r22, r24
 772:	6a 30       	cpi	r22, 0x0A	; 10
 774:	60 f4       	brcc	.+24     	; 0x78e <_Z4atoiPKc+0x48>
	{
		value *= 10;
 776:	92 9f       	mul	r25, r18
 778:	b0 01       	movw	r22, r0
 77a:	93 9f       	mul	r25, r19
 77c:	70 0d       	add	r23, r0
 77e:	11 24       	eor	r1, r1
		value += (int) (*c-'0');
 780:	28 2f       	mov	r18, r24
 782:	30 e0       	ldi	r19, 0x00	; 0
 784:	20 53       	subi	r18, 0x30	; 48
 786:	31 09       	sbc	r19, r1
 788:	26 0f       	add	r18, r22
 78a:	37 1f       	adc	r19, r23
	if( *c == '+' || *c == '-' )
	{
		if( *c == '-' ) sign = -1;
		c++;
	}
	while (*c >= '0' && *c <= '9')
 78c:	ef cf       	rjmp	.-34     	; 0x76c <_Z4atoiPKc+0x26>
		value *= 10;
		value += (int) (*c-'0');
		c++;
	}
	return (value * sign);
}
 78e:	24 9f       	mul	r18, r20
 790:	c0 01       	movw	r24, r0
 792:	25 9f       	mul	r18, r21
 794:	90 0d       	add	r25, r0
 796:	34 9f       	mul	r19, r20
 798:	90 0d       	add	r25, r0
 79a:	11 24       	eor	r1, r1
 79c:	08 95       	ret

0000079e <_Z4itoaiPci>:

// Yet, another good itoa implementation
// returns: the length of the number string
int itoa(int value, char *sp, int radix)
{
 79e:	ef 92       	push	r14
 7a0:	ff 92       	push	r15
 7a2:	0f 93       	push	r16
 7a4:	1f 93       	push	r17
 7a6:	cf 93       	push	r28
 7a8:	df 93       	push	r29
 7aa:	cd b7       	in	r28, 0x3d	; 61
 7ac:	de b7       	in	r29, 0x3e	; 62
 7ae:	60 97       	sbiw	r28, 0x10	; 16
 7b0:	0f b6       	in	r0, 0x3f	; 63
 7b2:	f8 94       	cli
 7b4:	de bf       	out	0x3e, r29	; 62
 7b6:	0f be       	out	0x3f, r0	; 63
 7b8:	cd bf       	out	0x3d, r28	; 61
 7ba:	fb 01       	movw	r30, r22
 7bc:	8a 01       	movw	r16, r20
	char tmp[16];// be careful with the length of the buffer
	char *tp = tmp;
	int i;
	unsigned v;

	int sign = (radix == 10 && value < 0);
 7be:	4a 30       	cpi	r20, 0x0A	; 10
 7c0:	51 05       	cpc	r21, r1
 7c2:	11 f4       	brne	.+4      	; 0x7c8 <_Z4itoaiPci+0x2a>
 7c4:	97 fd       	sbrc	r25, 7
 7c6:	2b c0       	rjmp	.+86     	; 0x81e <_Z4itoaiPci+0x80>
	if (sign)
	v = -value;
	else
	v = (unsigned)value;
 7c8:	bc 01       	movw	r22, r24
 7ca:	40 e0       	ldi	r20, 0x00	; 0
 7cc:	9e 01       	movw	r18, r28
 7ce:	2f 5f       	subi	r18, 0xFF	; 255
 7d0:	3f 4f       	sbci	r19, 0xFF	; 255
 7d2:	79 01       	movw	r14, r18
 7d4:	d9 01       	movw	r26, r18

	while (v || tp == tmp)
 7d6:	61 15       	cp	r22, r1
 7d8:	71 05       	cpc	r23, r1
 7da:	19 f4       	brne	.+6      	; 0x7e2 <_Z4itoaiPci+0x44>
 7dc:	e2 16       	cp	r14, r18
 7de:	f3 06       	cpc	r15, r19
 7e0:	79 f4       	brne	.+30     	; 0x800 <_Z4itoaiPci+0x62>
	{
		i = v % radix;
		v /= radix; // v/=radix uses less CPU clocks than v=v/radix does
 7e2:	cb 01       	movw	r24, r22
 7e4:	b8 01       	movw	r22, r16
 7e6:	0e 94 c2 07 	call	0xf84	; 0xf84 <__udivmodhi4>
		if (i < 10)
 7ea:	8a 30       	cpi	r24, 0x0A	; 10
 7ec:	91 05       	cpc	r25, r1
 7ee:	14 f4       	brge	.+4      	; 0x7f4 <_Z4itoaiPci+0x56>
		*tp++ = i+'0';
 7f0:	80 5d       	subi	r24, 0xD0	; 208
 7f2:	01 c0       	rjmp	.+2      	; 0x7f6 <_Z4itoaiPci+0x58>
		else
		*tp++ = i + 'a' - 10;
 7f4:	89 5a       	subi	r24, 0xA9	; 169
 7f6:	d9 01       	movw	r26, r18
 7f8:	8c 93       	st	X, r24
 7fa:	2f 5f       	subi	r18, 0xFF	; 255
 7fc:	3f 4f       	sbci	r19, 0xFF	; 255
 7fe:	ea cf       	rjmp	.-44     	; 0x7d4 <_Z4itoaiPci+0x36>
	}

	int len = tp - tmp;
 800:	c9 01       	movw	r24, r18
 802:	8e 19       	sub	r24, r14
 804:	9f 09       	sbc	r25, r15

	if (sign)
 806:	44 23       	and	r20, r20
 808:	21 f0       	breq	.+8      	; 0x812 <_Z4itoaiPci+0x74>
	{
		*sp++ = '-';
 80a:	2d e2       	ldi	r18, 0x2D	; 45
 80c:	20 83       	st	Z, r18
		len++;
 80e:	01 96       	adiw	r24, 0x01	; 1

	int len = tp - tmp;

	if (sign)
	{
		*sp++ = '-';
 810:	31 96       	adiw	r30, 0x01	; 1
		len++;
	}

	while (tp > tmp)
 812:	ea 16       	cp	r14, r26
 814:	fb 06       	cpc	r15, r27
 816:	48 f4       	brcc	.+18     	; 0x82a <_Z4itoaiPci+0x8c>
	*sp++ = *--tp;
 818:	2e 91       	ld	r18, -X
 81a:	21 93       	st	Z+, r18
	{
		*sp++ = '-';
		len++;
	}

	while (tp > tmp)
 81c:	fa cf       	rjmp	.-12     	; 0x812 <_Z4itoaiPci+0x74>
	int i;
	unsigned v;

	int sign = (radix == 10 && value < 0);
	if (sign)
	v = -value;
 81e:	66 27       	eor	r22, r22
 820:	77 27       	eor	r23, r23
 822:	68 1b       	sub	r22, r24
 824:	79 0b       	sbc	r23, r25
	char tmp[16];// be careful with the length of the buffer
	char *tp = tmp;
	int i;
	unsigned v;

	int sign = (radix == 10 && value < 0);
 826:	41 e0       	ldi	r20, 0x01	; 1
 828:	d1 cf       	rjmp	.-94     	; 0x7cc <_Z4itoaiPci+0x2e>

	while (tp > tmp)
	*sp++ = *--tp;

	return len;
 82a:	60 96       	adiw	r28, 0x10	; 16
 82c:	0f b6       	in	r0, 0x3f	; 63
 82e:	f8 94       	cli
 830:	de bf       	out	0x3e, r29	; 62
 832:	0f be       	out	0x3f, r0	; 63
 834:	cd bf       	out	0x3d, r28	; 61
 836:	df 91       	pop	r29
 838:	cf 91       	pop	r28
 83a:	1f 91       	pop	r17
 83c:	0f 91       	pop	r16
 83e:	ff 90       	pop	r15
 840:	ef 90       	pop	r14
 842:	08 95       	ret

00000844 <_Z9print_cmdPcPKciS1_S1_i>:
}

// Creates an access point with given ssid, password
int createServer(char const *ssid, char const *password, int debug = 0){
	return setSSID(ssid, debug) || setPassword(password, debug) || startAP(debug);
}
 844:	af 92       	push	r10
 846:	bf 92       	push	r11
 848:	cf 92       	push	r12
 84a:	df 92       	push	r13
 84c:	ef 92       	push	r14
 84e:	ff 92       	push	r15
 850:	0f 93       	push	r16
 852:	1f 93       	push	r17
 854:	cf 93       	push	r28
 856:	df 93       	push	r29
 858:	ec 01       	movw	r28, r24
 85a:	5b 01       	movw	r10, r22
 85c:	69 01       	movw	r12, r18
 85e:	45 2b       	or	r20, r21
 860:	21 f4       	brne	.+8      	; 0x86a <_Z9print_cmdPcPKciS1_S1_i+0x26>
 862:	63 ea       	ldi	r22, 0xA3	; 163
 864:	72 e0       	ldi	r23, 0x02	; 2
 866:	0e 94 75 03 	call	0x6ea	; 0x6ea <_Z6strcatPcPKc>
 86a:	b5 01       	movw	r22, r10
 86c:	ce 01       	movw	r24, r28
 86e:	0e 94 75 03 	call	0x6ea	; 0x6ea <_Z6strcatPcPKc>
 872:	6b e1       	ldi	r22, 0x1B	; 27
 874:	72 e0       	ldi	r23, 0x02	; 2
 876:	c6 01       	movw	r24, r12
 878:	0e 94 57 03 	call	0x6ae	; 0x6ae <_Z6strcmpPKcS0_>
 87c:	89 2b       	or	r24, r25
 87e:	19 f1       	breq	.+70     	; 0x8c6 <_Z9print_cmdPcPKciS1_S1_i+0x82>
 880:	66 ea       	ldi	r22, 0xA6	; 166
 882:	72 e0       	ldi	r23, 0x02	; 2
 884:	ce 01       	movw	r24, r28
 886:	0e 94 75 03 	call	0x6ea	; 0x6ea <_Z6strcatPcPKc>
 88a:	68 ea       	ldi	r22, 0xA8	; 168
 88c:	72 e0       	ldi	r23, 0x02	; 2
 88e:	ce 01       	movw	r24, r28
 890:	0e 94 75 03 	call	0x6ea	; 0x6ea <_Z6strcatPcPKc>
 894:	b6 01       	movw	r22, r12
 896:	ce 01       	movw	r24, r28
 898:	0e 94 75 03 	call	0x6ea	; 0x6ea <_Z6strcatPcPKc>
 89c:	68 ea       	ldi	r22, 0xA8	; 168
 89e:	72 e0       	ldi	r23, 0x02	; 2
 8a0:	ce 01       	movw	r24, r28
 8a2:	0e 94 75 03 	call	0x6ea	; 0x6ea <_Z6strcatPcPKc>
 8a6:	ef 28       	or	r14, r15
 8a8:	71 f0       	breq	.+28     	; 0x8c6 <_Z9print_cmdPcPKciS1_S1_i+0x82>
 8aa:	6a ea       	ldi	r22, 0xAA	; 170
 8ac:	72 e0       	ldi	r23, 0x02	; 2
 8ae:	ce 01       	movw	r24, r28
 8b0:	0e 94 75 03 	call	0x6ea	; 0x6ea <_Z6strcatPcPKc>
 8b4:	b8 01       	movw	r22, r16
 8b6:	ce 01       	movw	r24, r28
 8b8:	0e 94 75 03 	call	0x6ea	; 0x6ea <_Z6strcatPcPKc>
 8bc:	6c ea       	ldi	r22, 0xAC	; 172
 8be:	72 e0       	ldi	r23, 0x02	; 2
 8c0:	ce 01       	movw	r24, r28
 8c2:	0e 94 75 03 	call	0x6ea	; 0x6ea <_Z6strcatPcPKc>
 8c6:	6a e1       	ldi	r22, 0x1A	; 26
 8c8:	72 e0       	ldi	r23, 0x02	; 2
 8ca:	ce 01       	movw	r24, r28
 8cc:	df 91       	pop	r29
 8ce:	cf 91       	pop	r28
 8d0:	1f 91       	pop	r17
 8d2:	0f 91       	pop	r16
 8d4:	ff 90       	pop	r15
 8d6:	ef 90       	pop	r14
 8d8:	df 90       	pop	r13
 8da:	cf 90       	pop	r12
 8dc:	bf 90       	pop	r11
 8de:	af 90       	pop	r10
 8e0:	0c 94 75 03 	jmp	0x6ea	; 0x6ea <_Z6strcatPcPKc>

000008e4 <_Z10usart_initv>:
 8e4:	1b b8       	out	0x0b, r1	; 11
 8e6:	88 e1       	ldi	r24, 0x18	; 24
 8e8:	8a b9       	out	0x0a, r24	; 10
 8ea:	10 bc       	out	0x20, r1	; 32
 8ec:	83 e3       	ldi	r24, 0x33	; 51
 8ee:	89 b9       	out	0x09, r24	; 9
 8f0:	86 e8       	ldi	r24, 0x86	; 134
 8f2:	80 bd       	out	0x20, r24	; 32
 8f4:	08 95       	ret

000008f6 <_Z14usart_transmitc>:
 8f6:	5d 9b       	sbis	0x0b, 5	; 11
 8f8:	fe cf       	rjmp	.-4      	; 0x8f6 <_Z14usart_transmitc>
 8fa:	8c b9       	out	0x0c, r24	; 12
 8fc:	08 95       	ret

000008fe <_Z13usart_receivev>:
 8fe:	5f 9b       	sbis	0x0b, 7	; 11
 900:	fe cf       	rjmp	.-4      	; 0x8fe <_Z13usart_receivev>
 902:	8c b1       	in	r24, 0x0c	; 12
 904:	08 95       	ret

00000906 <_Z14transmitStringPKc>:
 906:	cf 93       	push	r28
 908:	df 93       	push	r29
 90a:	ec 01       	movw	r28, r24
 90c:	89 91       	ld	r24, Y+
 90e:	8a 30       	cpi	r24, 0x0A	; 10
 910:	19 f0       	breq	.+6      	; 0x918 <_Z14transmitStringPKc+0x12>
 912:	0e 94 7b 04 	call	0x8f6	; 0x8f6 <_Z14usart_transmitc>
 916:	fa cf       	rjmp	.-12     	; 0x90c <_Z14transmitStringPKc+0x6>
 918:	8a e0       	ldi	r24, 0x0A	; 10
 91a:	df 91       	pop	r29
 91c:	cf 91       	pop	r28
 91e:	0c 94 7b 04 	jmp	0x8f6	; 0x8f6 <_Z14usart_transmitc>

00000922 <_Z13receiveStringPc>:
 922:	0f 93       	push	r16
 924:	1f 93       	push	r17
 926:	cf 93       	push	r28
 928:	df 93       	push	r29
 92a:	ec 01       	movw	r28, r24
 92c:	0e 94 7f 04 	call	0x8fe	; 0x8fe <_Z13usart_receivev>
 930:	8e 01       	movw	r16, r28
 932:	f8 01       	movw	r30, r16
 934:	ec 1b       	sub	r30, r28
 936:	fd 0b       	sbc	r31, r29
 938:	8a 30       	cpi	r24, 0x0A	; 10
 93a:	31 f0       	breq	.+12     	; 0x948 <_Z13receiveStringPc+0x26>
 93c:	f8 01       	movw	r30, r16
 93e:	81 93       	st	Z+, r24
 940:	8f 01       	movw	r16, r30
 942:	0e 94 7f 04 	call	0x8fe	; 0x8fe <_Z13usart_receivev>
 946:	f5 cf       	rjmp	.-22     	; 0x932 <_Z13receiveStringPc+0x10>
 948:	ec 0f       	add	r30, r28
 94a:	fd 1f       	adc	r31, r29
 94c:	80 83       	st	Z, r24
 94e:	ce 01       	movw	r24, r28
 950:	df 91       	pop	r29
 952:	cf 91       	pop	r28
 954:	1f 91       	pop	r17
 956:	0f 91       	pop	r16
 958:	0c 94 83 04 	jmp	0x906	; 0x906 <_Z14transmitStringPKc>

0000095c <_Z12checkSuccessv>:
 95c:	cf 93       	push	r28
 95e:	df 93       	push	r29
 960:	cd b7       	in	r28, 0x3d	; 61
 962:	de b7       	in	r29, 0x3e	; 62
 964:	e2 97       	sbiw	r28, 0x32	; 50
 966:	0f b6       	in	r0, 0x3f	; 63
 968:	f8 94       	cli
 96a:	de bf       	out	0x3e, r29	; 62
 96c:	0f be       	out	0x3f, r0	; 63
 96e:	cd bf       	out	0x3d, r28	; 61
 970:	1a 82       	std	Y+2, r1	; 0x02
 972:	19 82       	std	Y+1, r1	; 0x01
 974:	fe 01       	movw	r30, r28
 976:	33 96       	adiw	r30, 0x03	; 3
 978:	80 e3       	ldi	r24, 0x30	; 48
 97a:	df 01       	movw	r26, r30
 97c:	1d 92       	st	X+, r1
 97e:	8a 95       	dec	r24
 980:	e9 f7       	brne	.-6      	; 0x97c <_Z12checkSuccessv+0x20>
 982:	ce 01       	movw	r24, r28
 984:	01 96       	adiw	r24, 0x01	; 1
 986:	0e 94 91 04 	call	0x922	; 0x922 <_Z13receiveStringPc>
 98a:	6e ea       	ldi	r22, 0xAE	; 174
 98c:	72 e0       	ldi	r23, 0x02	; 2
 98e:	ce 01       	movw	r24, r28
 990:	01 96       	adiw	r24, 0x01	; 1
 992:	0e 94 57 03 	call	0x6ae	; 0x6ae <_Z6strcmpPKcS0_>
 996:	e2 96       	adiw	r28, 0x32	; 50
 998:	0f b6       	in	r0, 0x3f	; 63
 99a:	f8 94       	cli
 99c:	de bf       	out	0x3e, r29	; 62
 99e:	0f be       	out	0x3f, r0	; 63
 9a0:	cd bf       	out	0x3d, r28	; 61
 9a2:	df 91       	pop	r29
 9a4:	cf 91       	pop	r28
 9a6:	08 95       	ret

000009a8 <_Z17parseSensorStringPc>:
 9a8:	0f 93       	push	r16
 9aa:	1f 93       	push	r17
 9ac:	cf 93       	push	r28
 9ae:	df 93       	push	r29
 9b0:	cd b7       	in	r28, 0x3d	; 61
 9b2:	de b7       	in	r29, 0x3e	; 62
 9b4:	e2 97       	sbiw	r28, 0x32	; 50
 9b6:	0f b6       	in	r0, 0x3f	; 63
 9b8:	f8 94       	cli
 9ba:	de bf       	out	0x3e, r29	; 62
 9bc:	0f be       	out	0x3f, r0	; 63
 9be:	cd bf       	out	0x3d, r28	; 61
 9c0:	8c 01       	movw	r16, r24
 9c2:	1a 82       	std	Y+2, r1	; 0x02
 9c4:	19 82       	std	Y+1, r1	; 0x01
 9c6:	fe 01       	movw	r30, r28
 9c8:	33 96       	adiw	r30, 0x03	; 3
 9ca:	80 e3       	ldi	r24, 0x30	; 48
 9cc:	df 01       	movw	r26, r30
 9ce:	1d 92       	st	X+, r1
 9d0:	8a 95       	dec	r24
 9d2:	e9 f7       	brne	.-6      	; 0x9ce <_Z17parseSensorStringPc+0x26>
 9d4:	ce 01       	movw	r24, r28
 9d6:	01 96       	adiw	r24, 0x01	; 1
 9d8:	0e 94 91 04 	call	0x922	; 0x922 <_Z13receiveStringPc>
 9dc:	6b e1       	ldi	r22, 0x1B	; 27
 9de:	72 e0       	ldi	r23, 0x02	; 2
 9e0:	c8 01       	movw	r24, r16
 9e2:	0e 94 91 03 	call	0x722	; 0x722 <_Z6strcpyPcPKc>
 9e6:	fe 01       	movw	r30, r28
 9e8:	31 96       	adiw	r30, 0x01	; 1
 9ea:	80 e0       	ldi	r24, 0x00	; 0
 9ec:	90 e0       	ldi	r25, 0x00	; 0
 9ee:	01 96       	adiw	r24, 0x01	; 1
 9f0:	21 91       	ld	r18, Z+
 9f2:	22 32       	cpi	r18, 0x22	; 34
 9f4:	e1 f7       	brne	.-8      	; 0x9ee <_Z17parseSensorStringPc+0x46>
 9f6:	e1 e0       	ldi	r30, 0x01	; 1
 9f8:	f0 e0       	ldi	r31, 0x00	; 0
 9fa:	ec 0f       	add	r30, r28
 9fc:	fd 1f       	adc	r31, r29
 9fe:	e8 0f       	add	r30, r24
 a00:	f9 1f       	adc	r31, r25
 a02:	d8 01       	movw	r26, r16
 a04:	cd 01       	movw	r24, r26
 a06:	80 1b       	sub	r24, r16
 a08:	91 0b       	sbc	r25, r17
 a0a:	21 91       	ld	r18, Z+
 a0c:	22 32       	cpi	r18, 0x22	; 34
 a0e:	11 f0       	breq	.+4      	; 0xa14 <_Z17parseSensorStringPc+0x6c>
 a10:	2d 93       	st	X+, r18
 a12:	f8 cf       	rjmp	.-16     	; 0xa04 <_Z17parseSensorStringPc+0x5c>
 a14:	f8 01       	movw	r30, r16
 a16:	e8 0f       	add	r30, r24
 a18:	f9 1f       	adc	r31, r25
 a1a:	8a e0       	ldi	r24, 0x0A	; 10
 a1c:	80 83       	st	Z, r24
 a1e:	e2 96       	adiw	r28, 0x32	; 50
 a20:	0f b6       	in	r0, 0x3f	; 63
 a22:	f8 94       	cli
 a24:	de bf       	out	0x3e, r29	; 62
 a26:	0f be       	out	0x3f, r0	; 63
 a28:	cd bf       	out	0x3d, r28	; 61
 a2a:	df 91       	pop	r29
 a2c:	cf 91       	pop	r28
 a2e:	1f 91       	pop	r17
 a30:	0f 91       	pop	r16
 a32:	08 95       	ret

00000a34 <_Z11parseSensorv>:
 a34:	1f 93       	push	r17
 a36:	cf 93       	push	r28
 a38:	df 93       	push	r29
 a3a:	cd b7       	in	r28, 0x3d	; 61
 a3c:	de b7       	in	r29, 0x3e	; 62
 a3e:	c4 56       	subi	r28, 0x64	; 100
 a40:	d1 09       	sbc	r29, r1
 a42:	0f b6       	in	r0, 0x3f	; 63
 a44:	f8 94       	cli
 a46:	de bf       	out	0x3e, r29	; 62
 a48:	0f be       	out	0x3f, r0	; 63
 a4a:	cd bf       	out	0x3d, r28	; 61
 a4c:	1c aa       	std	Y+52, r1	; 0x34
 a4e:	1b aa       	std	Y+51, r1	; 0x33
 a50:	10 e3       	ldi	r17, 0x30	; 48
 a52:	fe 01       	movw	r30, r28
 a54:	f5 96       	adiw	r30, 0x35	; 53
 a56:	df 01       	movw	r26, r30
 a58:	81 2f       	mov	r24, r17
 a5a:	1d 92       	st	X+, r1
 a5c:	8a 95       	dec	r24
 a5e:	e9 f7       	brne	.-6      	; 0xa5a <_Z11parseSensorv+0x26>
 a60:	ce 01       	movw	r24, r28
 a62:	c3 96       	adiw	r24, 0x33	; 51
 a64:	0e 94 91 04 	call	0x922	; 0x922 <_Z13receiveStringPc>
 a68:	1a 82       	std	Y+2, r1	; 0x02
 a6a:	19 82       	std	Y+1, r1	; 0x01
 a6c:	fe 01       	movw	r30, r28
 a6e:	33 96       	adiw	r30, 0x03	; 3
 a70:	df 01       	movw	r26, r30
 a72:	1d 92       	st	X+, r1
 a74:	1a 95       	dec	r17
 a76:	e9 f7       	brne	.-6      	; 0xa72 <_Z11parseSensorv+0x3e>
 a78:	f0 96       	adiw	r30, 0x30	; 48
 a7a:	80 e0       	ldi	r24, 0x00	; 0
 a7c:	90 e0       	ldi	r25, 0x00	; 0
 a7e:	01 96       	adiw	r24, 0x01	; 1
 a80:	21 91       	ld	r18, Z+
 a82:	22 32       	cpi	r18, 0x22	; 34
 a84:	e1 f7       	brne	.-8      	; 0xa7e <_Z11parseSensorv+0x4a>
 a86:	e3 e3       	ldi	r30, 0x33	; 51
 a88:	f0 e0       	ldi	r31, 0x00	; 0
 a8a:	ec 0f       	add	r30, r28
 a8c:	fd 1f       	adc	r31, r29
 a8e:	e8 0f       	add	r30, r24
 a90:	f9 1f       	adc	r31, r25
 a92:	de 01       	movw	r26, r28
 a94:	11 96       	adiw	r26, 0x01	; 1
 a96:	cd 01       	movw	r24, r26
 a98:	21 91       	ld	r18, Z+
 a9a:	22 32       	cpi	r18, 0x22	; 34
 a9c:	11 f0       	breq	.+4      	; 0xaa2 <_Z11parseSensorv+0x6e>
 a9e:	2d 93       	st	X+, r18
 aa0:	fb cf       	rjmp	.-10     	; 0xa98 <_Z11parseSensorv+0x64>
 aa2:	0e 94 a3 03 	call	0x746	; 0x746 <_Z4atoiPKc>
 aa6:	cc 59       	subi	r28, 0x9C	; 156
 aa8:	df 4f       	sbci	r29, 0xFF	; 255
 aaa:	0f b6       	in	r0, 0x3f	; 63
 aac:	f8 94       	cli
 aae:	de bf       	out	0x3e, r29	; 62
 ab0:	0f be       	out	0x3f, r0	; 63
 ab2:	cd bf       	out	0x3d, r28	; 61
 ab4:	df 91       	pop	r29
 ab6:	cf 91       	pop	r28
 ab8:	1f 91       	pop	r17
 aba:	08 95       	ret

00000abc <_Z7restarti>:
 abc:	af 92       	push	r10
 abe:	bf 92       	push	r11
 ac0:	df 92       	push	r13
 ac2:	ef 92       	push	r14
 ac4:	ff 92       	push	r15
 ac6:	0f 93       	push	r16
 ac8:	1f 93       	push	r17
 aca:	cf 93       	push	r28
 acc:	df 93       	push	r29
 ace:	cd b7       	in	r28, 0x3d	; 61
 ad0:	de b7       	in	r29, 0x3e	; 62
 ad2:	c4 56       	subi	r28, 0x64	; 100
 ad4:	d1 09       	sbc	r29, r1
 ad6:	0f b6       	in	r0, 0x3f	; 63
 ad8:	f8 94       	cli
 ada:	de bf       	out	0x3e, r29	; 62
 adc:	0f be       	out	0x3f, r0	; 63
 ade:	cd bf       	out	0x3d, r28	; 61
 ae0:	5c 01       	movw	r10, r24
 ae2:	8a e1       	ldi	r24, 0x1A	; 26
 ae4:	92 e0       	ldi	r25, 0x02	; 2
 ae6:	0e 94 83 04 	call	0x906	; 0x906 <_Z14transmitStringPKc>
 aea:	1c aa       	std	Y+52, r1	; 0x34
 aec:	1b aa       	std	Y+51, r1	; 0x33
 aee:	80 e3       	ldi	r24, 0x30	; 48
 af0:	d8 2e       	mov	r13, r24
 af2:	fe 01       	movw	r30, r28
 af4:	f5 96       	adiw	r30, 0x35	; 53
 af6:	df 01       	movw	r26, r30
 af8:	8d 2d       	mov	r24, r13
 afa:	1d 92       	st	X+, r1
 afc:	8a 95       	dec	r24
 afe:	e9 f7       	brne	.-6      	; 0xafa <_Z7restarti+0x3e>
 b00:	e1 2c       	mov	r14, r1
 b02:	f1 2c       	mov	r15, r1
 b04:	0b e1       	ldi	r16, 0x1B	; 27
 b06:	12 e0       	ldi	r17, 0x02	; 2
 b08:	98 01       	movw	r18, r16
 b0a:	a5 01       	movw	r20, r10
 b0c:	69 eb       	ldi	r22, 0xB9	; 185
 b0e:	72 e0       	ldi	r23, 0x02	; 2
 b10:	ce 01       	movw	r24, r28
 b12:	c3 96       	adiw	r24, 0x33	; 51
 b14:	0e 94 22 04 	call	0x844	; 0x844 <_Z9print_cmdPcPKciS1_S1_i>
 b18:	ce 01       	movw	r24, r28
 b1a:	c3 96       	adiw	r24, 0x33	; 51
 b1c:	0e 94 83 04 	call	0x906	; 0x906 <_Z14transmitStringPKc>
 b20:	1a 82       	std	Y+2, r1	; 0x02
 b22:	19 82       	std	Y+1, r1	; 0x01
 b24:	fe 01       	movw	r30, r28
 b26:	33 96       	adiw	r30, 0x03	; 3
 b28:	df 01       	movw	r26, r30
 b2a:	1d 92       	st	X+, r1
 b2c:	da 94       	dec	r13
 b2e:	e9 f7       	brne	.-6      	; 0xb2a <_Z7restarti+0x6e>
 b30:	ce 01       	movw	r24, r28
 b32:	01 96       	adiw	r24, 0x01	; 1
 b34:	0e 94 91 04 	call	0x922	; 0x922 <_Z13receiveStringPc>
 b38:	ce 01       	movw	r24, r28
 b3a:	01 96       	adiw	r24, 0x01	; 1
 b3c:	0e 94 91 04 	call	0x922	; 0x922 <_Z13receiveStringPc>
 b40:	80 e0       	ldi	r24, 0x00	; 0
 b42:	90 e0       	ldi	r25, 0x00	; 0
 b44:	cc 59       	subi	r28, 0x9C	; 156
 b46:	df 4f       	sbci	r29, 0xFF	; 255
 b48:	0f b6       	in	r0, 0x3f	; 63
 b4a:	f8 94       	cli
 b4c:	de bf       	out	0x3e, r29	; 62
 b4e:	0f be       	out	0x3f, r0	; 63
 b50:	cd bf       	out	0x3d, r28	; 61
 b52:	df 91       	pop	r29
 b54:	cf 91       	pop	r28
 b56:	1f 91       	pop	r17
 b58:	0f 91       	pop	r16
 b5a:	ff 90       	pop	r15
 b5c:	ef 90       	pop	r14
 b5e:	df 90       	pop	r13
 b60:	bf 90       	pop	r11
 b62:	af 90       	pop	r10
 b64:	08 95       	ret

00000b66 <_Z7setSSIDPKci>:
 b66:	ef 92       	push	r14
 b68:	ff 92       	push	r15
 b6a:	0f 93       	push	r16
 b6c:	1f 93       	push	r17
 b6e:	cf 93       	push	r28
 b70:	df 93       	push	r29
 b72:	cd b7       	in	r28, 0x3d	; 61
 b74:	de b7       	in	r29, 0x3e	; 62
 b76:	e2 97       	sbiw	r28, 0x32	; 50
 b78:	0f b6       	in	r0, 0x3f	; 63
 b7a:	f8 94       	cli
 b7c:	de bf       	out	0x3e, r29	; 62
 b7e:	0f be       	out	0x3f, r0	; 63
 b80:	cd bf       	out	0x3d, r28	; 61
 b82:	ab 01       	movw	r20, r22
 b84:	1a 82       	std	Y+2, r1	; 0x02
 b86:	19 82       	std	Y+1, r1	; 0x01
 b88:	fe 01       	movw	r30, r28
 b8a:	33 96       	adiw	r30, 0x03	; 3
 b8c:	20 e3       	ldi	r18, 0x30	; 48
 b8e:	df 01       	movw	r26, r30
 b90:	1d 92       	st	X+, r1
 b92:	2a 95       	dec	r18
 b94:	e9 f7       	brne	.-6      	; 0xb90 <_Z7setSSIDPKci+0x2a>
 b96:	e1 2c       	mov	r14, r1
 b98:	f1 2c       	mov	r15, r1
 b9a:	0b e1       	ldi	r16, 0x1B	; 27
 b9c:	12 e0       	ldi	r17, 0x02	; 2
 b9e:	9c 01       	movw	r18, r24
 ba0:	61 ec       	ldi	r22, 0xC1	; 193
 ba2:	72 e0       	ldi	r23, 0x02	; 2
 ba4:	ce 01       	movw	r24, r28
 ba6:	01 96       	adiw	r24, 0x01	; 1
 ba8:	0e 94 22 04 	call	0x844	; 0x844 <_Z9print_cmdPcPKciS1_S1_i>
 bac:	ce 01       	movw	r24, r28
 bae:	01 96       	adiw	r24, 0x01	; 1
 bb0:	0e 94 83 04 	call	0x906	; 0x906 <_Z14transmitStringPKc>
 bb4:	0e 94 ae 04 	call	0x95c	; 0x95c <_Z12checkSuccessv>
 bb8:	e2 96       	adiw	r28, 0x32	; 50
 bba:	0f b6       	in	r0, 0x3f	; 63
 bbc:	f8 94       	cli
 bbe:	de bf       	out	0x3e, r29	; 62
 bc0:	0f be       	out	0x3f, r0	; 63
 bc2:	cd bf       	out	0x3d, r28	; 61
 bc4:	df 91       	pop	r29
 bc6:	cf 91       	pop	r28
 bc8:	1f 91       	pop	r17
 bca:	0f 91       	pop	r16
 bcc:	ff 90       	pop	r15
 bce:	ef 90       	pop	r14
 bd0:	08 95       	ret

00000bd2 <_Z11setPasswordPKci>:
 bd2:	ef 92       	push	r14
 bd4:	ff 92       	push	r15
 bd6:	0f 93       	push	r16
 bd8:	1f 93       	push	r17
 bda:	cf 93       	push	r28
 bdc:	df 93       	push	r29
 bde:	cd b7       	in	r28, 0x3d	; 61
 be0:	de b7       	in	r29, 0x3e	; 62
 be2:	e2 97       	sbiw	r28, 0x32	; 50
 be4:	0f b6       	in	r0, 0x3f	; 63
 be6:	f8 94       	cli
 be8:	de bf       	out	0x3e, r29	; 62
 bea:	0f be       	out	0x3f, r0	; 63
 bec:	cd bf       	out	0x3d, r28	; 61
 bee:	ab 01       	movw	r20, r22
 bf0:	1a 82       	std	Y+2, r1	; 0x02
 bf2:	19 82       	std	Y+1, r1	; 0x01
 bf4:	fe 01       	movw	r30, r28
 bf6:	33 96       	adiw	r30, 0x03	; 3
 bf8:	20 e3       	ldi	r18, 0x30	; 48
 bfa:	df 01       	movw	r26, r30
 bfc:	1d 92       	st	X+, r1
 bfe:	2a 95       	dec	r18
 c00:	e9 f7       	brne	.-6      	; 0xbfc <_Z11setPasswordPKci+0x2a>
 c02:	e1 2c       	mov	r14, r1
 c04:	f1 2c       	mov	r15, r1
 c06:	0b e1       	ldi	r16, 0x1B	; 27
 c08:	12 e0       	ldi	r17, 0x02	; 2
 c0a:	9c 01       	movw	r18, r24
 c0c:	66 ec       	ldi	r22, 0xC6	; 198
 c0e:	72 e0       	ldi	r23, 0x02	; 2
 c10:	ce 01       	movw	r24, r28
 c12:	01 96       	adiw	r24, 0x01	; 1
 c14:	0e 94 22 04 	call	0x844	; 0x844 <_Z9print_cmdPcPKciS1_S1_i>
 c18:	ce 01       	movw	r24, r28
 c1a:	01 96       	adiw	r24, 0x01	; 1
 c1c:	0e 94 83 04 	call	0x906	; 0x906 <_Z14transmitStringPKc>
 c20:	0e 94 ae 04 	call	0x95c	; 0x95c <_Z12checkSuccessv>
 c24:	e2 96       	adiw	r28, 0x32	; 50
 c26:	0f b6       	in	r0, 0x3f	; 63
 c28:	f8 94       	cli
 c2a:	de bf       	out	0x3e, r29	; 62
 c2c:	0f be       	out	0x3f, r0	; 63
 c2e:	cd bf       	out	0x3d, r28	; 61
 c30:	df 91       	pop	r29
 c32:	cf 91       	pop	r28
 c34:	1f 91       	pop	r17
 c36:	0f 91       	pop	r16
 c38:	ff 90       	pop	r15
 c3a:	ef 90       	pop	r14
 c3c:	08 95       	ret

00000c3e <_Z7connecti>:

// Connects to access point (client)
int connect(int debug = 0){
 c3e:	ef 92       	push	r14
 c40:	ff 92       	push	r15
 c42:	0f 93       	push	r16
 c44:	1f 93       	push	r17
 c46:	cf 93       	push	r28
 c48:	df 93       	push	r29
 c4a:	cd b7       	in	r28, 0x3d	; 61
 c4c:	de b7       	in	r29, 0x3e	; 62
 c4e:	e2 97       	sbiw	r28, 0x32	; 50
 c50:	0f b6       	in	r0, 0x3f	; 63
 c52:	f8 94       	cli
 c54:	de bf       	out	0x3e, r29	; 62
 c56:	0f be       	out	0x3f, r0	; 63
 c58:	cd bf       	out	0x3d, r28	; 61
	char cmd[CMD] = "";
 c5a:	1a 82       	std	Y+2, r1	; 0x02
 c5c:	19 82       	std	Y+1, r1	; 0x01
 c5e:	fe 01       	movw	r30, r28
 c60:	33 96       	adiw	r30, 0x03	; 3
 c62:	20 e3       	ldi	r18, 0x30	; 48
 c64:	df 01       	movw	r26, r30
 c66:	1d 92       	st	X+, r1
 c68:	2a 95       	dec	r18
 c6a:	e9 f7       	brne	.-6      	; 0xc66 <_Z7connecti+0x28>
	
	print_cmd(cmd, "connect", debug);
 c6c:	e1 2c       	mov	r14, r1
 c6e:	f1 2c       	mov	r15, r1
 c70:	0b e1       	ldi	r16, 0x1B	; 27
 c72:	12 e0       	ldi	r17, 0x02	; 2
 c74:	98 01       	movw	r18, r16
 c76:	ac 01       	movw	r20, r24
 c78:	66 e8       	ldi	r22, 0x86	; 134
 c7a:	70 e0       	ldi	r23, 0x00	; 0
 c7c:	ce 01       	movw	r24, r28
 c7e:	01 96       	adiw	r24, 0x01	; 1
 c80:	0e 94 22 04 	call	0x844	; 0x844 <_Z9print_cmdPcPKciS1_S1_i>
	transmitString(cmd);
 c84:	ce 01       	movw	r24, r28
 c86:	01 96       	adiw	r24, 0x01	; 1
 c88:	0e 94 83 04 	call	0x906	; 0x906 <_Z14transmitStringPKc>

	return checkSuccess();
 c8c:	0e 94 ae 04 	call	0x95c	; 0x95c <_Z12checkSuccessv>
}
 c90:	e2 96       	adiw	r28, 0x32	; 50
 c92:	0f b6       	in	r0, 0x3f	; 63
 c94:	f8 94       	cli
 c96:	de bf       	out	0x3e, r29	; 62
 c98:	0f be       	out	0x3f, r0	; 63
 c9a:	cd bf       	out	0x3d, r28	; 61
 c9c:	df 91       	pop	r29
 c9e:	cf 91       	pop	r28
 ca0:	1f 91       	pop	r17
 ca2:	0f 91       	pop	r16
 ca4:	ff 90       	pop	r15
 ca6:	ef 90       	pop	r14
 ca8:	08 95       	ret

00000caa <_Z15connectToServerPKcS0_i>:

// Connects to server using given ssid, password
int connectToServer(char const *ssid, char const *password, int debug = 0){
 caa:	0f 93       	push	r16
 cac:	1f 93       	push	r17
 cae:	cf 93       	push	r28
 cb0:	df 93       	push	r29
 cb2:	8b 01       	movw	r16, r22
 cb4:	ea 01       	movw	r28, r20
	return setSSID(ssid, debug) || setPassword(password, debug) || connect(debug);
 cb6:	ba 01       	movw	r22, r20
 cb8:	0e 94 b3 05 	call	0xb66	; 0xb66 <_Z7setSSIDPKci>
 cbc:	89 2b       	or	r24, r25
 cbe:	11 f0       	breq	.+4      	; 0xcc4 <_Z15connectToServerPKcS0_i+0x1a>
 cc0:	21 e0       	ldi	r18, 0x01	; 1
 cc2:	0d c0       	rjmp	.+26     	; 0xcde <_Z15connectToServerPKcS0_i+0x34>
 cc4:	be 01       	movw	r22, r28
 cc6:	c8 01       	movw	r24, r16
 cc8:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <_Z11setPasswordPKci>
 ccc:	89 2b       	or	r24, r25
 cce:	c1 f7       	brne	.-16     	; 0xcc0 <_Z15connectToServerPKcS0_i+0x16>
 cd0:	ce 01       	movw	r24, r28
 cd2:	0e 94 1f 06 	call	0xc3e	; 0xc3e <_Z7connecti>
 cd6:	21 e0       	ldi	r18, 0x01	; 1
 cd8:	89 2b       	or	r24, r25
 cda:	09 f4       	brne	.+2      	; 0xcde <_Z15connectToServerPKcS0_i+0x34>
 cdc:	20 e0       	ldi	r18, 0x00	; 0
}
 cde:	82 2f       	mov	r24, r18
 ce0:	90 e0       	ldi	r25, 0x00	; 0
 ce2:	df 91       	pop	r29
 ce4:	cf 91       	pop	r28
 ce6:	1f 91       	pop	r17
 ce8:	0f 91       	pop	r16
 cea:	08 95       	ret

00000cec <_Z9newSensorPKci>:

// Adds a new sensor that will be handled by the device
int newSensor(char const *sensor, int debug = 0){
 cec:	ef 92       	push	r14
 cee:	ff 92       	push	r15
 cf0:	0f 93       	push	r16
 cf2:	1f 93       	push	r17
 cf4:	cf 93       	push	r28
 cf6:	df 93       	push	r29
 cf8:	cd b7       	in	r28, 0x3d	; 61
 cfa:	de b7       	in	r29, 0x3e	; 62
 cfc:	e2 97       	sbiw	r28, 0x32	; 50
 cfe:	0f b6       	in	r0, 0x3f	; 63
 d00:	f8 94       	cli
 d02:	de bf       	out	0x3e, r29	; 62
 d04:	0f be       	out	0x3f, r0	; 63
 d06:	cd bf       	out	0x3d, r28	; 61
 d08:	ab 01       	movw	r20, r22
	char cmd[CMD] = "";
 d0a:	1a 82       	std	Y+2, r1	; 0x02
 d0c:	19 82       	std	Y+1, r1	; 0x01
 d0e:	fe 01       	movw	r30, r28
 d10:	33 96       	adiw	r30, 0x03	; 3
 d12:	20 e3       	ldi	r18, 0x30	; 48
 d14:	df 01       	movw	r26, r30
 d16:	1d 92       	st	X+, r1
 d18:	2a 95       	dec	r18
 d1a:	e9 f7       	brne	.-6      	; 0xd16 <_Z9newSensorPKci+0x2a>
	
	print_cmd(cmd, "addSensor", debug, sensor);
 d1c:	e1 2c       	mov	r14, r1
 d1e:	f1 2c       	mov	r15, r1
 d20:	0b e1       	ldi	r16, 0x1B	; 27
 d22:	12 e0       	ldi	r17, 0x02	; 2
 d24:	9c 01       	movw	r18, r24
 d26:	67 ed       	ldi	r22, 0xD7	; 215
 d28:	72 e0       	ldi	r23, 0x02	; 2
 d2a:	ce 01       	movw	r24, r28
 d2c:	01 96       	adiw	r24, 0x01	; 1
 d2e:	0e 94 22 04 	call	0x844	; 0x844 <_Z9print_cmdPcPKciS1_S1_i>
	transmitString(cmd);
 d32:	ce 01       	movw	r24, r28
 d34:	01 96       	adiw	r24, 0x01	; 1
 d36:	0e 94 83 04 	call	0x906	; 0x906 <_Z14transmitStringPKc>

	return checkSuccess();
 d3a:	0e 94 ae 04 	call	0x95c	; 0x95c <_Z12checkSuccessv>
}
 d3e:	e2 96       	adiw	r28, 0x32	; 50
 d40:	0f b6       	in	r0, 0x3f	; 63
 d42:	f8 94       	cli
 d44:	de bf       	out	0x3e, r29	; 62
 d46:	0f be       	out	0x3f, r0	; 63
 d48:	cd bf       	out	0x3d, r28	; 61
 d4a:	df 91       	pop	r29
 d4c:	cf 91       	pop	r28
 d4e:	1f 91       	pop	r17
 d50:	0f 91       	pop	r16
 d52:	ff 90       	pop	r15
 d54:	ef 90       	pop	r14
 d56:	08 95       	ret

00000d58 <_Z14setSensorValuePKcS0_i>:

// Sets the value of a sensor (string)
int setSensorValue(char const *sensor, char const *value, int debug = 0){
 d58:	ef 92       	push	r14
 d5a:	ff 92       	push	r15
 d5c:	0f 93       	push	r16
 d5e:	1f 93       	push	r17
 d60:	cf 93       	push	r28
 d62:	df 93       	push	r29
 d64:	cd b7       	in	r28, 0x3d	; 61
 d66:	de b7       	in	r29, 0x3e	; 62
 d68:	e2 97       	sbiw	r28, 0x32	; 50
 d6a:	0f b6       	in	r0, 0x3f	; 63
 d6c:	f8 94       	cli
 d6e:	de bf       	out	0x3e, r29	; 62
 d70:	0f be       	out	0x3f, r0	; 63
 d72:	cd bf       	out	0x3d, r28	; 61
	char cmd[CMD] = "";
 d74:	1a 82       	std	Y+2, r1	; 0x02
 d76:	19 82       	std	Y+1, r1	; 0x01
 d78:	fe 01       	movw	r30, r28
 d7a:	33 96       	adiw	r30, 0x03	; 3
 d7c:	20 e3       	ldi	r18, 0x30	; 48
 d7e:	df 01       	movw	r26, r30
 d80:	1d 92       	st	X+, r1
 d82:	2a 95       	dec	r18
 d84:	e9 f7       	brne	.-6      	; 0xd80 <_Z14setSensorValuePKcS0_i+0x28>
	
	print_cmd(cmd, "sensorValue", debug, sensor, value, 1);
 d86:	ee 24       	eor	r14, r14
 d88:	e3 94       	inc	r14
 d8a:	f1 2c       	mov	r15, r1
 d8c:	8b 01       	movw	r16, r22
 d8e:	9c 01       	movw	r18, r24
 d90:	61 ee       	ldi	r22, 0xE1	; 225
 d92:	72 e0       	ldi	r23, 0x02	; 2
 d94:	ce 01       	movw	r24, r28
 d96:	01 96       	adiw	r24, 0x01	; 1
 d98:	0e 94 22 04 	call	0x844	; 0x844 <_Z9print_cmdPcPKciS1_S1_i>
	transmitString(cmd);
 d9c:	ce 01       	movw	r24, r28
 d9e:	01 96       	adiw	r24, 0x01	; 1
 da0:	0e 94 83 04 	call	0x906	; 0x906 <_Z14transmitStringPKc>
	
	return checkSuccess();
 da4:	0e 94 ae 04 	call	0x95c	; 0x95c <_Z12checkSuccessv>
}
 da8:	e2 96       	adiw	r28, 0x32	; 50
 daa:	0f b6       	in	r0, 0x3f	; 63
 dac:	f8 94       	cli
 dae:	de bf       	out	0x3e, r29	; 62
 db0:	0f be       	out	0x3f, r0	; 63
 db2:	cd bf       	out	0x3d, r28	; 61
 db4:	df 91       	pop	r29
 db6:	cf 91       	pop	r28
 db8:	1f 91       	pop	r17
 dba:	0f 91       	pop	r16
 dbc:	ff 90       	pop	r15
 dbe:	ef 90       	pop	r14
 dc0:	08 95       	ret

00000dc2 <_Z12setSensorIntPKcii>:

// Sets the value of a sensor (int)
int setSensorInt(char const *sensor, int value, int debug = 0){
 dc2:	ef 92       	push	r14
 dc4:	ff 92       	push	r15
 dc6:	0f 93       	push	r16
 dc8:	1f 93       	push	r17
 dca:	cf 93       	push	r28
 dcc:	df 93       	push	r29
 dce:	cd b7       	in	r28, 0x3d	; 61
 dd0:	de b7       	in	r29, 0x3e	; 62
 dd2:	e2 97       	sbiw	r28, 0x32	; 50
 dd4:	0f b6       	in	r0, 0x3f	; 63
 dd6:	f8 94       	cli
 dd8:	de bf       	out	0x3e, r29	; 62
 dda:	0f be       	out	0x3f, r0	; 63
 ddc:	cd bf       	out	0x3d, r28	; 61
 dde:	8c 01       	movw	r16, r24
 de0:	cb 01       	movw	r24, r22
 de2:	7a 01       	movw	r14, r20
	char v[CMD] = "";
 de4:	1a 82       	std	Y+2, r1	; 0x02
 de6:	19 82       	std	Y+1, r1	; 0x01
 de8:	fe 01       	movw	r30, r28
 dea:	33 96       	adiw	r30, 0x03	; 3
 dec:	20 e3       	ldi	r18, 0x30	; 48
 dee:	df 01       	movw	r26, r30
 df0:	1d 92       	st	X+, r1
 df2:	2a 95       	dec	r18
 df4:	e9 f7       	brne	.-6      	; 0xdf0 <_Z12setSensorIntPKcii+0x2e>
	itoa(value, v, 10);
 df6:	4a e0       	ldi	r20, 0x0A	; 10
 df8:	50 e0       	ldi	r21, 0x00	; 0
 dfa:	be 01       	movw	r22, r28
 dfc:	6f 5f       	subi	r22, 0xFF	; 255
 dfe:	7f 4f       	sbci	r23, 0xFF	; 255
 e00:	0e 94 cf 03 	call	0x79e	; 0x79e <_Z4itoaiPci>

	return setSensorValue(sensor, v, debug);
 e04:	a7 01       	movw	r20, r14
 e06:	be 01       	movw	r22, r28
 e08:	6f 5f       	subi	r22, 0xFF	; 255
 e0a:	7f 4f       	sbci	r23, 0xFF	; 255
 e0c:	c8 01       	movw	r24, r16
 e0e:	0e 94 ac 06 	call	0xd58	; 0xd58 <_Z14setSensorValuePKcS0_i>
}
 e12:	e2 96       	adiw	r28, 0x32	; 50
 e14:	0f b6       	in	r0, 0x3f	; 63
 e16:	f8 94       	cli
 e18:	de bf       	out	0x3e, r29	; 62
 e1a:	0f be       	out	0x3f, r0	; 63
 e1c:	cd bf       	out	0x3d, r28	; 61
 e1e:	df 91       	pop	r29
 e20:	cf 91       	pop	r28
 e22:	1f 91       	pop	r17
 e24:	0f 91       	pop	r16
 e26:	ff 90       	pop	r15
 e28:	ef 90       	pop	r14
 e2a:	08 95       	ret

00000e2c <_Z18requestSensorValuePKci>:

// Sets the value of a sensor to request,
// so that it will request a value from the server on transmit
int requestSensorValue(char const *sensor, int debug = 0){
 e2c:	ab 01       	movw	r20, r22
	return setSensorValue(sensor, "request", debug);
 e2e:	6d ee       	ldi	r22, 0xED	; 237
 e30:	72 e0       	ldi	r23, 0x02	; 2
 e32:	0c 94 ac 06 	jmp	0xd58	; 0xd58 <_Z14setSensorValuePKcS0_i>

00000e36 <_Z15getSensorStringPKcPci>:
}

void getSensorString(char const *sensor, char *dest, int debug = 0){
 e36:	cf 92       	push	r12
 e38:	df 92       	push	r13
 e3a:	ef 92       	push	r14
 e3c:	ff 92       	push	r15
 e3e:	0f 93       	push	r16
 e40:	1f 93       	push	r17
 e42:	cf 93       	push	r28
 e44:	df 93       	push	r29
 e46:	cd b7       	in	r28, 0x3d	; 61
 e48:	de b7       	in	r29, 0x3e	; 62
 e4a:	e2 97       	sbiw	r28, 0x32	; 50
 e4c:	0f b6       	in	r0, 0x3f	; 63
 e4e:	f8 94       	cli
 e50:	de bf       	out	0x3e, r29	; 62
 e52:	0f be       	out	0x3f, r0	; 63
 e54:	cd bf       	out	0x3d, r28	; 61
 e56:	6b 01       	movw	r12, r22
	char cmd[CMD] = "";
 e58:	1a 82       	std	Y+2, r1	; 0x02
 e5a:	19 82       	std	Y+1, r1	; 0x01
 e5c:	fe 01       	movw	r30, r28
 e5e:	33 96       	adiw	r30, 0x03	; 3
 e60:	20 e3       	ldi	r18, 0x30	; 48
 e62:	df 01       	movw	r26, r30
 e64:	1d 92       	st	X+, r1
 e66:	2a 95       	dec	r18
 e68:	e9 f7       	brne	.-6      	; 0xe64 <_Z15getSensorStringPKcPci+0x2e>
	
	print_cmd(cmd, "getValue", debug, sensor);
 e6a:	e1 2c       	mov	r14, r1
 e6c:	f1 2c       	mov	r15, r1
 e6e:	0b e1       	ldi	r16, 0x1B	; 27
 e70:	12 e0       	ldi	r17, 0x02	; 2
 e72:	9c 01       	movw	r18, r24
 e74:	65 ef       	ldi	r22, 0xF5	; 245
 e76:	72 e0       	ldi	r23, 0x02	; 2
 e78:	ce 01       	movw	r24, r28
 e7a:	01 96       	adiw	r24, 0x01	; 1
 e7c:	0e 94 22 04 	call	0x844	; 0x844 <_Z9print_cmdPcPKciS1_S1_i>
	transmitString(cmd);
 e80:	ce 01       	movw	r24, r28
 e82:	01 96       	adiw	r24, 0x01	; 1
 e84:	0e 94 83 04 	call	0x906	; 0x906 <_Z14transmitStringPKc>

	parseSensorString(dest);
 e88:	c6 01       	movw	r24, r12
 e8a:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <_Z17parseSensorStringPc>
}
 e8e:	e2 96       	adiw	r28, 0x32	; 50
 e90:	0f b6       	in	r0, 0x3f	; 63
 e92:	f8 94       	cli
 e94:	de bf       	out	0x3e, r29	; 62
 e96:	0f be       	out	0x3f, r0	; 63
 e98:	cd bf       	out	0x3d, r28	; 61
 e9a:	df 91       	pop	r29
 e9c:	cf 91       	pop	r28
 e9e:	1f 91       	pop	r17
 ea0:	0f 91       	pop	r16
 ea2:	ff 90       	pop	r15
 ea4:	ef 90       	pop	r14
 ea6:	df 90       	pop	r13
 ea8:	cf 90       	pop	r12
 eaa:	08 95       	ret

00000eac <_Z14getSensorValuePKci>:

// Gets the value of given sensor
int getSensorValue(char const *sensor, int debug = 0){
 eac:	ef 92       	push	r14
 eae:	ff 92       	push	r15
 eb0:	0f 93       	push	r16
 eb2:	1f 93       	push	r17
 eb4:	cf 93       	push	r28
 eb6:	df 93       	push	r29
 eb8:	cd b7       	in	r28, 0x3d	; 61
 eba:	de b7       	in	r29, 0x3e	; 62
 ebc:	e2 97       	sbiw	r28, 0x32	; 50
 ebe:	0f b6       	in	r0, 0x3f	; 63
 ec0:	f8 94       	cli
 ec2:	de bf       	out	0x3e, r29	; 62
 ec4:	0f be       	out	0x3f, r0	; 63
 ec6:	cd bf       	out	0x3d, r28	; 61
 ec8:	ab 01       	movw	r20, r22
	char cmd[CMD] = "";
 eca:	1a 82       	std	Y+2, r1	; 0x02
 ecc:	19 82       	std	Y+1, r1	; 0x01
 ece:	fe 01       	movw	r30, r28
 ed0:	33 96       	adiw	r30, 0x03	; 3
 ed2:	20 e3       	ldi	r18, 0x30	; 48
 ed4:	df 01       	movw	r26, r30
 ed6:	1d 92       	st	X+, r1
 ed8:	2a 95       	dec	r18
 eda:	e9 f7       	brne	.-6      	; 0xed6 <_Z14getSensorValuePKci+0x2a>
	
	print_cmd(cmd, "getValue", debug, sensor);
 edc:	e1 2c       	mov	r14, r1
 ede:	f1 2c       	mov	r15, r1
 ee0:	0b e1       	ldi	r16, 0x1B	; 27
 ee2:	12 e0       	ldi	r17, 0x02	; 2
 ee4:	9c 01       	movw	r18, r24
 ee6:	65 ef       	ldi	r22, 0xF5	; 245
 ee8:	72 e0       	ldi	r23, 0x02	; 2
 eea:	ce 01       	movw	r24, r28
 eec:	01 96       	adiw	r24, 0x01	; 1
 eee:	0e 94 22 04 	call	0x844	; 0x844 <_Z9print_cmdPcPKciS1_S1_i>
	transmitString(cmd);
 ef2:	ce 01       	movw	r24, r28
 ef4:	01 96       	adiw	r24, 0x01	; 1
 ef6:	0e 94 83 04 	call	0x906	; 0x906 <_Z14transmitStringPKc>

	return parseSensor();
 efa:	0e 94 1a 05 	call	0xa34	; 0xa34 <_Z11parseSensorv>
}
 efe:	e2 96       	adiw	r28, 0x32	; 50
 f00:	0f b6       	in	r0, 0x3f	; 63
 f02:	f8 94       	cli
 f04:	de bf       	out	0x3e, r29	; 62
 f06:	0f be       	out	0x3f, r0	; 63
 f08:	cd bf       	out	0x3d, r28	; 61
 f0a:	df 91       	pop	r29
 f0c:	cf 91       	pop	r28
 f0e:	1f 91       	pop	r17
 f10:	0f 91       	pop	r16
 f12:	ff 90       	pop	r15
 f14:	ef 90       	pop	r14
 f16:	08 95       	ret

00000f18 <_Z14clientTransmiti>:

//getAllSensorValues

// Send all sensor values/requests to connected devices
int clientTransmit(int debug = 0){
 f18:	ef 92       	push	r14
 f1a:	ff 92       	push	r15
 f1c:	0f 93       	push	r16
 f1e:	1f 93       	push	r17
 f20:	cf 93       	push	r28
 f22:	df 93       	push	r29
 f24:	cd b7       	in	r28, 0x3d	; 61
 f26:	de b7       	in	r29, 0x3e	; 62
 f28:	e2 97       	sbiw	r28, 0x32	; 50
 f2a:	0f b6       	in	r0, 0x3f	; 63
 f2c:	f8 94       	cli
 f2e:	de bf       	out	0x3e, r29	; 62
 f30:	0f be       	out	0x3f, r0	; 63
 f32:	cd bf       	out	0x3d, r28	; 61
	char cmd[CMD] = "";
 f34:	1a 82       	std	Y+2, r1	; 0x02
 f36:	19 82       	std	Y+1, r1	; 0x01
 f38:	fe 01       	movw	r30, r28
 f3a:	33 96       	adiw	r30, 0x03	; 3
 f3c:	20 e3       	ldi	r18, 0x30	; 48
 f3e:	df 01       	movw	r26, r30
 f40:	1d 92       	st	X+, r1
 f42:	2a 95       	dec	r18
 f44:	e9 f7       	brne	.-6      	; 0xf40 <_Z14clientTransmiti+0x28>
	
	print_cmd(cmd, "clientTransmit", debug);
 f46:	e1 2c       	mov	r14, r1
 f48:	f1 2c       	mov	r15, r1
 f4a:	0b e1       	ldi	r16, 0x1B	; 27
 f4c:	12 e0       	ldi	r17, 0x02	; 2
 f4e:	98 01       	movw	r18, r16
 f50:	ac 01       	movw	r20, r24
 f52:	6e ef       	ldi	r22, 0xFE	; 254
 f54:	72 e0       	ldi	r23, 0x02	; 2
 f56:	ce 01       	movw	r24, r28
 f58:	01 96       	adiw	r24, 0x01	; 1
 f5a:	0e 94 22 04 	call	0x844	; 0x844 <_Z9print_cmdPcPKciS1_S1_i>
	transmitString(cmd);
 f5e:	ce 01       	movw	r24, r28
 f60:	01 96       	adiw	r24, 0x01	; 1
 f62:	0e 94 83 04 	call	0x906	; 0x906 <_Z14transmitStringPKc>

	return checkSuccess();
 f66:	0e 94 ae 04 	call	0x95c	; 0x95c <_Z12checkSuccessv>
 f6a:	e2 96       	adiw	r28, 0x32	; 50
 f6c:	0f b6       	in	r0, 0x3f	; 63
 f6e:	f8 94       	cli
 f70:	de bf       	out	0x3e, r29	; 62
 f72:	0f be       	out	0x3f, r0	; 63
 f74:	cd bf       	out	0x3d, r28	; 61
 f76:	df 91       	pop	r29
 f78:	cf 91       	pop	r28
 f7a:	1f 91       	pop	r17
 f7c:	0f 91       	pop	r16
 f7e:	ff 90       	pop	r15
 f80:	ef 90       	pop	r14
 f82:	08 95       	ret

00000f84 <__udivmodhi4>:
 f84:	aa 1b       	sub	r26, r26
 f86:	bb 1b       	sub	r27, r27
 f88:	51 e1       	ldi	r21, 0x11	; 17
 f8a:	07 c0       	rjmp	.+14     	; 0xf9a <__udivmodhi4_ep>

00000f8c <__udivmodhi4_loop>:
 f8c:	aa 1f       	adc	r26, r26
 f8e:	bb 1f       	adc	r27, r27
 f90:	a6 17       	cp	r26, r22
 f92:	b7 07       	cpc	r27, r23
 f94:	10 f0       	brcs	.+4      	; 0xf9a <__udivmodhi4_ep>
 f96:	a6 1b       	sub	r26, r22
 f98:	b7 0b       	sbc	r27, r23

00000f9a <__udivmodhi4_ep>:
 f9a:	88 1f       	adc	r24, r24
 f9c:	99 1f       	adc	r25, r25
 f9e:	5a 95       	dec	r21
 fa0:	a9 f7       	brne	.-22     	; 0xf8c <__udivmodhi4_loop>
 fa2:	80 95       	com	r24
 fa4:	90 95       	com	r25
 fa6:	bc 01       	movw	r22, r24
 fa8:	cd 01       	movw	r24, r26
 faa:	08 95       	ret

00000fac <__divmodhi4>:
 fac:	97 fb       	bst	r25, 7
 fae:	07 2e       	mov	r0, r23
 fb0:	16 f4       	brtc	.+4      	; 0xfb6 <__divmodhi4+0xa>
 fb2:	00 94       	com	r0
 fb4:	07 d0       	rcall	.+14     	; 0xfc4 <__divmodhi4_neg1>
 fb6:	77 fd       	sbrc	r23, 7
 fb8:	09 d0       	rcall	.+18     	; 0xfcc <__divmodhi4_neg2>
 fba:	0e 94 c2 07 	call	0xf84	; 0xf84 <__udivmodhi4>
 fbe:	07 fc       	sbrc	r0, 7
 fc0:	05 d0       	rcall	.+10     	; 0xfcc <__divmodhi4_neg2>
 fc2:	3e f4       	brtc	.+14     	; 0xfd2 <__divmodhi4_exit>

00000fc4 <__divmodhi4_neg1>:
 fc4:	90 95       	com	r25
 fc6:	81 95       	neg	r24
 fc8:	9f 4f       	sbci	r25, 0xFF	; 255
 fca:	08 95       	ret

00000fcc <__divmodhi4_neg2>:
 fcc:	70 95       	com	r23
 fce:	61 95       	neg	r22
 fd0:	7f 4f       	sbci	r23, 0xFF	; 255

00000fd2 <__divmodhi4_exit>:
 fd2:	08 95       	ret

00000fd4 <_exit>:
 fd4:	f8 94       	cli

00000fd6 <__stop_program>:
 fd6:	ff cf       	rjmp	.-2      	; 0xfd6 <__stop_program>
